# S3 同期を利用したノート管理アプリ - 仕様書

このドキュメントは、AWS S3 を利用したノート管理アプリの設計、同期ロジック、およびユーザーの操作手順に関する仕様をまとめています。このシステムは、インデックスベースのバージョン管理機能を使用してファイルの変更を追跡し、複数の PC 間でノートの同期を可能にします。

## 目次

1. [メモリポジトリの設定ディレクトリ](#メモリポジトリの設定ディレクトリ)
2. [インデックスの構造](#インデックスの構造)
3. [同期のワークフロー](#同期のワークフロー)
4. [競合の検出と解決](#競合の検出と解決)
5. [条件付き Put による競合防止](#条件付きputによる競合防止)
6. [HEAD の復旧メカニズム](#headの復旧メカニズム)
7. [セキュリティと暗号化](#セキュリティと暗号化)
8. [操作手順](#操作手順)
   - [メモリポジトリの新規作成](#メモリポジトリの新規作成)
   - [登録したリモートリポジトリへの同期](#登録したリモートリポジトリへの同期)
   - [別の PC で既存のリモートリポジトリからの初回同期](#別のpcで既存のリモートリポジトリからの初回同期)
9. [今後の検討事項](#今後の検討事項)

---

## 1. メモリポジトリの設定ディレクトリ

### `.memo` ディレクトリの概要:

メモリポジトリの設定情報やローカルのインデックスファイルは、ワークスペースのルートディレクトリに `.memo` という名前のディレクトリに集約されます。このディレクトリは、以下の用途で使用されます。

- **同期先の設定情報**:
  - AWS S3 のバケット名や同期に使用するリモートリポジトリのパス（prefix path）などが含まれます。
- **ローカルインデックスファイルの保存**:
  - 各ローカルのインデックスファイルはこのディレクトリ内に保存されます。
- **その他の内部管理情報**:
  - ログや一時的な情報など、アプリケーションが必要とする他のファイルも `.memo` ディレクトリ内に格納されます。

### 同期時の `.memo` ディレクトリの除外:

- ローカルとリモートを同期する際、`.memo` ディレクトリは同期の対象外とされ、リモートにはアップロードされません。このディレクトリはアプリケーション内部での管理にのみ使用されます。

---

## 2. インデックスの構造

各インデックスファイルは、ワークスペース内のファイルの状態を追跡し、変更履歴を保持します。インデックスは連続的な構造を持ち、`nextUuid` フィールドを使用して次のインデックスを明示的にリンクします。

```ts
interface IndexFile {
  uuid: string; // インデックスの一意な識別子
  parentUuid: string; // 親インデックスのUUID
  nextUuid: string; // 次のインデックスのUUID
  files: FileEntry[]; // ファイルとそのハッシュのリスト
  timestamp: number; // インデックスが作成されたタイムスタンプ
}

interface FileEntry {
  path: string; // ファイルのパス
  hash: string; // ファイル内容のハッシュ値（SHA-256）
  timestamp: number; // ファイルの最終更新日時
}
```

### `nextUuid` の使用:

- 新しいインデックスファイルが作成される際、親インデックスの `nextUuid` が新しいインデックスの `uuid` となります。
- 生成された新しいインデックスファイルには、次に続く `nextUuid` が含まれ、これにより一貫したインデックスの連鎖が保たれます。

### HEAD ファイル:

- `HEAD` ファイルは最新のインデックスファイル（`uuid`）を指し示す重要なファイルです。
- S3 では `HEAD` ファイルの更新はインデックスファイルの作成が成功した場合にのみ行います。これにより同期の整合性を確保します。

---

## 3. 同期のワークフロー

### ファイル同期のプロセス:

1. **ローカルインデックスの生成**:

   - ローカルワークスペースをスキャンし、ファイルのハッシュ値を計算して `IndexFile` オブジェクトを作成します。新しいインデックスには、`parentUuid` と `nextUuid` が設定され、`.memo` ディレクトリに保存されます。

2. **競合の検出**:

   - クライアントは最新の `HEAD` インデックスを S3 から取得し、ローカルインデックスと比較します。
   - 同じファイルがローカルとリモートで異なる場合、競合が検出されます。

3. **新規または変更されたファイルのアップロード**:

   - 競合がなければ、新規または変更されたファイルを暗号化し、S3 にアップロードします。

4. **インデックスのアップロード**:

   - 新しいインデックスファイルをアップロードする際、S3 の条件付き Put を使用して既存のファイルの上書きを防ぎます。
   - インデックスファイルのアップロードが成功すれば、次に `HEAD` ファイルを更新します。

5. **HEAD の更新**:
   - 新しいインデックスが正しくアップロードされた後、`HEAD` ファイルをそのインデックスに更新します。この操作に失敗した場合でも、`nextUuid` から次のインデックスファイルを辿ることで復旧が可能です。

---

## 4. 競合の検出と解決

### 競合の検出:

1. **ローカルとリモートのインデックス比較**:

   - ローカルとリモートのインデックス（`HEAD` が指し示すインデックス）を比較し、同じファイルのハッシュ値が異なる場合は競合として検出します。

2. **競合がある場合**:
   - 競合が検出された場合、クライアントはユーザーに対して選択を促します。ユーザーは以下の選択肢から競合解決を行います。
     - ローカルの変更を保持（リモートファイルを上書き）。
     - リモートの変更を保持（ローカルファイルを上書き）。
     - マージを手動で行う。

### 競合がない場合:

- 競合が検出されない場合、通常の同期処理が進み、インデックスファイルがアップロードされ、`HEAD` が更新されます。

---

## 5. 条件付き Put による競合防止

S3 では、**条件付き Put**機能を活用することで、**同名のファイルの上書きを防止**し、インデックスファイルの競合判定を S3 側で処理できます。

### 条件付き Put の流れ:

1. インデックスファイルのアップロード時に、S3 は既存のファイルが存在するかをチェックします。
2. 既に同じ `uuid` を持つファイルが存在する場合、アップロードが失敗し、競合が発生したとみなします。
3. この処理により、競合判定が S3 側で行われ、クライアント側での競合処理がオフロードされます。

### `HEAD` ファイルの更新:

- インデックスファイルのアップロードが成功した場合にのみ `HEAD` ファイルの更新が行われます。これにより、`HEAD` ファイルの競合は発生しません。
- 万が一 `HEAD` ファイルの更新が失敗した場合でも、次の

セクションで述べるように `nextUuid` を使って復旧が可能です。

---

## 6. HEAD の復旧メカニズム

`HEAD` ファイルの更新に失敗した場合、`nextUuid` を使用して復旧が可能です。

### HEAD ファイルの復旧手順:

1. 最新の `HEAD` が指し示すインデックスファイルを取得し、その `nextUuid` を確認します。
2. その `nextUuid` を持つインデックスファイルが存在するか確認します。
3. 存在する場合、そのインデックスファイルを新しい `HEAD` として更新します。

これにより、`HEAD` ファイルの更新がエラーで失敗した場合でも、インデックスの整合性を保ちながら復旧が可能です。

---

## 7. セキュリティと暗号化

### 暗号化:

- すべてのファイルおよびインデックスファイルは、S3 にアップロードされる前に AES-256 で暗号化されます。

### 暗号化キー:

- AES 暗号化キーは、VSCode の `SecretStorage` API を使用して安全に保存されます。
- ファイルおよびインデックスはアップロード前に暗号化され、ローカル環境から S3 までエンドツーエンドの暗号化を保証します。

### S3 へのセキュアアクセス:

- S3 バケットへのアクセスは、AWS IAM ポリシーによって制御されます。
- 各ユーザーやクライアントには、S3 バケット内のファイルの読み取り、書き込み、削除のための適切な権限が付与されます。

---

## 8. 操作手順

### 8.1 メモリポジトリの新規作成

1. VSCode のコマンドパレットで「Create New Memo Repository」を選択。
2. AWS S3 バケット名とリモートの保存場所（prefix path）を指定。
3. ワークスペースのルートディレクトリに `.memo` ディレクトリが作成され、同期先の設定情報やローカルインデックスファイルが保存される。
4. 最初のインデックスと HEAD ファイルが S3 にアップロードされ、初回同期が完了。

### 8.2 登録したリモートリポジトリへの同期

1. VSCode のコマンドパレットで「Sync Memo Repository」を選択。
2. ローカルとリモートのインデックスを比較し、差分を確認。
3. 新規または変更されたファイルをリモートにアップロード。
4. 必要に応じて競合を解決し、HEAD ファイルが更新される。

### 8.3 別の PC で既存のリモートリポジトリからの初回同期

1. 別の PC で VSCode のコマンドパレットから「Initialize Memo Repository from Remote」を選択。
2. リモートの HEAD ファイルとインデックスを取得。
3. リモートリポジトリ内のファイルがローカルにダウンロードされる。
4. ローカルでのメモ編集が可能になり、以降通常の同期操作が行える。

---

## 9. 今後の検討事項

### バージョン履歴とロールバック:

- 今後、バージョン履歴機能を実装することで、ユーザーが過去の状態にロールバックできるようにすることが検討されています。
- 各インデックスファイルの `parentUuid` や `nextUuid` を活用して、過去のバージョンへの移動を容易にする予定です。

### 協調編集:

- 複数のユーザーやクライアントが同時にノートを編集するシナリオでは、**競合解決アルゴリズム**の改善や、**CRDT（Conflict-Free Replicated Data Types）**などの技術を活用した競合の自動解決が検討されています。
