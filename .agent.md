# Secure Notes Sync - VS Code Extension

## Project Overview

**Purpose**: A Visual Studio Code extension for securely managing and synchronizing notes (or other files) with a GitHub repository using AES encryption and branch-based version control.

**Language**: TypeScript  
**Framework**: VS Code Extension API  
**Build System**: Webpack + TypeScript  
**Testing**: VS Code Test Framework with Mocha  
**License**: See [LICENSE](LICENSE)

## Key Features

- **üîí Secure Sync**: Encrypt files with AES-256-CBC before syncing to GitHub
- **üåø Branch Management**: Create and switch between branches for different development lines
- **‚ö° Auto-Sync**: Optional sync on save or after periods of inactivity
- **üîë AES Key Management**: Generate keys, retrieve from 1Password CLI, or manual input
- **üîÑ Conflict Resolution**: Detect and resolve merge conflicts automatically
- **üå≥ Tree View**: Visualize branches and historical indexes in the activity bar
- **üèóÔ∏è Dependency Injection**: Modern DI container for testable and maintainable code
- **üìã Index History**: View and navigate through historical index states

## Project Structure

### Core Files

- `src/extension.ts` - Main extension entry point with command registration and activation logic
- `src/SyncService.ts` - Core synchronization service with incremental sync logic
- `src/types.ts` - TypeScript interfaces for FileEntry, IndexFile, and other core types
- `src/config.ts` - Configuration utilities and settings management
- `src/logger.ts` - Custom terminal-based logging with ANSI colors

### Dependency Injection Container

- `src/container/ServiceContainer.ts` - Core DI container with lifecycle management
- `src/container/ContainerBuilder.ts` - Fluent builder for container configuration
- `src/container/ServiceLocator.ts` - Global service locator pattern implementation
- `src/container/ServiceKeys.ts` - Type-safe service key constants

### Interfaces & Abstractions

- `src/interfaces/ISyncService.ts` - Sync service interface for testability
- `src/interfaces/ISyncServiceFactory.ts` - Factory interface with configuration types

### Factories

- `src/factories/SyncServiceFactory.ts` - Factory for creating sync services with dependencies

### Configuration Management

- `src/config/ConfigManager.ts` - Centralized configuration management with validation

### Storage Layer

- `src/storage/IStorageProvider.ts` - Interface for storage providers
- `src/storage/GithubProvider.ts` - GitHub-based storage implementation
- `src/storage/LocalObjectManager.ts` - Local file encryption, indexing, and workspace management

### UI Components

- `src/BranchTreeViewProvider.ts` - Tree view provider for branch and index visualization
- `src/IndexHistoryProvider.ts` - Tree view provider for index history navigation

### Test Files

- `src/test/extension.test.ts` - Basic extension functionality tests
- `src/test/SyncService.test.ts` - Comprehensive sync service tests with mocks
- `src/test/LocalObjectManager.test.ts` - Local object manager unit tests
- `src/test/GitHubProvider.test.ts` - GitHub provider unit tests
- `src/test/integration.test.ts` - Integration tests for end-to-end scenarios
- `src/test/unit-test.ts` - Fast unit test runner
- `src/test/alternative-test-runner.ts` - Alternative test execution
- `src/test/manual-sync-test.ts` - Manual sync testing utilities
- `.vscode-test.mjs` - VS Code test runner configuration

### Configuration Files

- `package.json` - Extension manifest with commands, views, and configuration schema
- `webpack.config.js` - Build configuration for bundling
- `tsconfig.json` - TypeScript compiler configuration
- `eslint.config.mjs` - ESLint configuration with TypeScript rules

### Documentation

- `docs/spec.md` - Detailed technical specification in Japanese
- `docs/source-code-mapping.md` - Source code structure mapping
- `docs/sync-process-detailed-analysis.md` - Detailed sync process analysis
- `docs/architecture-update-summary.md` - Architecture update overview and migration guide

## Architecture and Practices

To avoid duplication, the canonical guidance is maintained in GEMINI.md. Refer to:

- GEMINI.md ‚Üí ‚ÄúExtension Architecture‚Äù and ‚ÄúDependency Injection Best Practices‚Äù
- GEMINI.md ‚Üí ‚ÄúEncryption Strategy‚Äù, ‚ÄúVersion Control Model‚Äù, and ‚ÄúFile Organization‚Äù
- GEMINI.md ‚Üí ‚ÄúConfiguration Management‚Äù and ‚ÄúConfiguration Schema‚Äù
- GEMINI.md ‚Üí ‚ÄúCode Style & Patterns‚Äù and ‚ÄúError Handling Patterns‚Äù
- GEMINI.md ‚Üí ‚ÄúStorage Conventions‚Äù
- GEMINI.md ‚Üí ‚ÄúTesting Guidelines‚Äù and ‚ÄúTesting Best Practices‚Äù

## Configuration and Commands

See GEMINI.md for the authoritative ‚ÄúConfiguration Schema‚Äù and ‚ÄúCommands‚Äù sections.

## Testing

For structure, mocks, and best practices, see GEMINI.md ‚Üí ‚ÄúTesting Guidelines‚Äù, ‚ÄúTesting Best Practices‚Äù.
Local commands remain:

```bash
pnpm run test        # VS Code tests
pnpm run test:unit   # TS-only tests via tsx
pnpm run test:fast   # Unit + lint
```

## Build and Development

### Development Workflow

```bash
pnpm install             # Install dependencies
pnpm run compile         # Build for development
pnpm run watch           # Watch mode for development
F5                      # Launch extension in new VS Code window
```

### Testing Best Practices

- **Always use headless mode**: `pnpm run test:headless` for consistent results
- **Test isolation**: Each test should be independent and clean up after itself
- **Mock external dependencies**: Use mocks for VS Code API, file system, and GitHub operations
- **Environment setup**: Ensure proper workspace and context mocking for LocalObjectManager tests

### Production Build

```bash
pnpm run package         # Build optimized bundle
pnpm run vscode:prepublish # Prepare for publishing
```

### Dependencies

- **Runtime**: `uuid` (UUID generation), `which` (CLI tool detection)
- **Development**: TypeScript, Webpack, ESLint, VS Code types, Mocha, tsx (fast TypeScript execution)

## Security

See GEMINI.md ‚Üí ‚ÄúSecurity Considerations‚Äù for encryption, key handling, and Git guidance.

## Troubleshooting

### Common Issues

- **AES Key not set**: Run "Generate AES Key" or "Set AES Key" command
- **Git remote not configured**: Set `gitRemoteUrl` in extension settings
- **1Password CLI issues**: Ensure `op` is in PATH and properly authenticated
- **Sync conflicts**: Extension automatically resolves with conflict file creation
- **Test failures**: Always use `pnpm run test:headless` to avoid display-related issues
- **Display errors**: Use headless mode (`xvfb-run -a`) for all automated testing
- **Workspace not found errors**: Ensure proper workspace mocking in test setup
- **Service resolution errors**: Check ServiceLocator initialization and container setup
- **Configuration validation errors**: Verify encryption key format (64 hex chars) and remote URL

### Dependency Injection Troubleshooting

- **Service not registered**: Check ContainerBuilder configuration and service keys
- **Circular dependencies**: Review service registration order and dependencies
- **Lifetime issues**: Verify appropriate service lifetimes (Singleton/Scoped/Transient)
- **Mock setup failures**: Ensure proper container configuration in test setup

### Debug Information

- Check the "SecureNoteSync Log" terminal for detailed logs
- Use VS Code Developer Tools for extension debugging
- Verify `.secureNotes` directory structure and permissions
- Check Git configuration and SSH key setup
- For test debugging: Use `console.log` in test files and run `pnpm run test:headless`
- Monitor test output for specific error patterns and mock setup issues

### Performance Considerations

- Large file handling: Consider chunking for very large files
- Network timeouts: Implement retry logic for GitHub operations
- Memory usage: Monitor memory consumption during sync operations

## Extension Activation

The extension activates when a workspace contains `.secureNotes/wsIndex.json`, indicating an initialized secure notes repository. The activation process:

1. **Container Setup**: Initialize the dependency injection container using `ContainerBuilder`
2. **Service Registration**: Register core services, VS Code services, and storage providers
3. **Command Registration**: Register all extension commands with proper dependency injection
4. **UI Initialization**: Set up tree view providers for branches and index history
5. **Event Handlers**: Configure auto-sync and file watching events

## Contributing

### Development Setup

1. Clone the repository
2. Run `pnpm install`
3. Open in VS Code
4. Press F5 to launch extension development host

### Code Quality

- All code must pass ESLint checks
- Add tests for new functionality
- Update documentation for API changes
- Follow existing code patterns and conventions

### Pull Request Guidelines

- Include tests for new features
- Update relevant documentation
- Ensure all tests pass
- Follow conventional commit messages

## AI Assistant Guidelines (GEMINI.md Summary)

For detailed guidance, see `GEMINI.md`. Key points to keep AI-generated changes aligned:

- Context: TypeScript + VS Code API, bundled via webpack. Core services live under `container/`, `factories/`, `interfaces/`, and storage under `storage/`.
- Security: Use AES-256-CBC with a random IV per file. Never log AES keys or decrypted content. Store secrets via VS Code SecretStorage; optionally retrieve via 1Password CLI.
- Data layout: `.secureNotes/HEAD`, `wsIndex.json`, and `remotes/{refs,indexes,files}`. Hash-based file paths (first 2 chars as dir) and UUID-based index paths (first 6 chars as dir).
- Architecture: Register commands in `activate()` and dispose with `context.subscriptions`. Implement providers following `IStorageProvider` and construct services via `SyncServiceFactory` and the DI container.
- Code style: TypeScript strict mode; obey `eslint.config.mjs` (e.g., `prefer-const`, `eqeqeq`); 2-space indent and semicolons with Prettier.
- Testing: Prefer fast unit tests via `pnpm run test:unit`; use VS Code tests for integration. Mock Git and 1Password, use temp dirs, and keep tests deterministic.
- Error handling: Use the `logger` for user-friendly messages and detailed logs. Gracefully handle network/Git failures; provide recovery suggestions where possible.
- Performance: Cache keys when appropriate, prefer incremental sync, and surface progress for long operations.
