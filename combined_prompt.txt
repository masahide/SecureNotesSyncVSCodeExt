ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯vscodeæ‹¡å¼µã®ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚
ã“ã®æ‹¡å¼µã¯vscodeãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã«ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æš—å·åŒ–ã—indexãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã£ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ä¿å­˜ã—ã¾ã™ã€‚
ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’gitã‚³ãƒãƒ³ãƒ‰ã§githubã®ãƒªãƒã‚¸ãƒˆãƒªã«åŒæœŸã™ã‚‹æ©Ÿèƒ½ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚

### Start of webpack.config.js ###
//@ts-check

'use strict';

const path = require('path');

//@ts-check
/** @typedef {import('webpack').Configuration} WebpackConfig **/

/** @type WebpackConfig */
const extensionConfig = {
  target: 'node', // VS Code extensions run in a Node.js-context ğŸ“– -> https://webpack.js.org/configuration/node/
	mode: 'none', // this leaves the source code as close as possible to the original (when packaging we set this to 'production')

  entry: './src/extension.ts', // the entry point of this extension, ğŸ“– -> https://webpack.js.org/configuration/entry-context/
  output: {
    // the bundle is stored in the 'dist' folder (check package.json), ğŸ“– -> https://webpack.js.org/configuration/output/
    path: path.resolve(__dirname, 'dist'),
    filename: 'extension.js',
    libraryTarget: 'commonjs2'
  },
  externals: {
    vscode: 'commonjs vscode' // the vscode-module is created on-the-fly and must be excluded. Add other modules that cannot be webpack'ed, ğŸ“– -> https://webpack.js.org/configuration/externals/
    // modules added here also need to be added in the .vscodeignore file
  },
  resolve: {
    // support reading TypeScript and JavaScript files, ğŸ“– -> https://github.com/TypeStrong/ts-loader
    extensions: ['.ts', '.js']
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        exclude: /node_modules/,
        use: [
          {
            loader: 'ts-loader'
          }
        ]
      }
    ]
  },
  devtool: 'nosources-source-map',
  infrastructureLogging: {
    level: "log", // enables logging required for problem matchers
  },
};
module.exports = [ extensionConfig ];
### End of webpack.config.js ###

### Start of src/envUtils.ts ###
// src/envUtils.ts
import * as vscode from "vscode";
import * as os from "os";
import * as crypto from "crypto";

const ENV_ID_KEY = "encryptSyncEnvironmentId";

export async function getOrCreateEnvironmentId(context: vscode.ExtensionContext): Promise<string> {
    let envId = context.globalState.get<string>(ENV_ID_KEY);
    if (!envId) {
        const hostname = os.hostname();
        envId = `${hostname}-${crypto.randomUUID()}`;
        await context.globalState.update(ENV_ID_KEY, envId);
    }
    return envId;
}

### End of src/envUtils.ts ###

### Start of src/extension.ts ###
// VSCode Extension Skeleton for Note-Taking App with S3 Integration
import * as vscode from "vscode";
import { logMessage, showInfo, showError, setOutputChannel } from "./logger";
import { setSecret } from "./secretManager";
import { LocalObjectManager } from "./storage/LocalObjectManager";
import { getOrCreateEnvironmentId } from "./envUtils";
import * as crypto from "crypto";


const aesEncryptionKey = "aesEncryptionKey";
const appName = "SecureNotesSync";

export async function activate(context: vscode.ExtensionContext) {
  // Create output channel
  const outputChannel = vscode.window.createOutputChannel(appName);
  setOutputChannel(outputChannel);
  showInfo(`${appName} Extension Activated`);

  // ç’°å¢ƒIDã‚’ç”Ÿæˆorå–å¾— (ãƒ›ã‚¹ãƒˆå + UUID)
  const environmentId = await getOrCreateEnvironmentId(context);
  logMessage(`Current Environment ID: ${environmentId}`);

  // Command to Set AES Key
  let setAESKeyCommand = vscode.commands.registerCommand("extension.setAESKey", () =>
    setSecret(context,
      aesEncryptionKey,
      "Enter AES Encryption Key (64 hex characters representing 32 bytes)",
      true,
      (value) => value.length === 64 ? null : "AES Key must be 64 hex characters long"
    )
  );

  // Command to Set AWS Credentials
  let setAWSSecretCommand = vscode.commands.registerCommand("extension.setAWSSecretCommand", async () => {
    const awsAccessKeyId = await vscode.window.showInputBox({
      prompt: "Enter AWS Access Key ID",
    });
    const awsSecretAccessKey = await vscode.window.showInputBox({
      prompt: "Enter AWS Secret Access Key",
      password: true,
    });

    if (awsAccessKeyId && awsSecretAccessKey) {
      const config = vscode.workspace.getConfiguration(appName);
      await config.update("awsAccessKeyId", awsAccessKeyId, vscode.ConfigurationTarget.Global);
      await context.secrets.store("awsSecretAccessKey", awsSecretAccessKey);
      showInfo("AWS Credentials saved successfully.");
    } else {
      showError("Both AWS Access Key ID and Secret Access Key are required.");
    }
  });

  // Command to Generate 32-Byte Encrypted Text
  let generateAESKeyCommand = vscode.commands.registerCommand("extension.generateAESKey", async () => {
    logMessage("Generating 32-byte AES encryption key...");
    const key = crypto.randomBytes(32).toString("hex"); // 32 bytes
    try {
      await context.secrets.store("aesEncryptionKey", key);
      showInfo(`Generated and stored AES key: ${key}`);
    } catch (error: any) {
      showError(`Error generating encrypted text: ${error instanceof Error ? error.message : String(error)}`);
    }
  });

  let syncCommand = vscode.commands.registerCommand("extension.syncNotes", async () => {
    try {
      // 1. S3ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæº–å‚™
      const encryptKey = await context.secrets.get(aesEncryptionKey);
      if (!encryptKey) {
        showError("AES Key not set");
        return false;
      }
      const config = vscode.workspace.getConfiguration("encryptSync");
      const options = { environmentId, encryptionKey: encryptKey };
      // const awsAccessKeyId = config.get<string>("awsAccessKeyId");
      // const awsSecretAccessKey = await context.secrets.get("awsSecretAccessKey");
      // const s3Bucket = config.get<string>("s3Bucket");
      // const s3Region = config.get<string>("s3Region");
      // if (!awsAccessKeyId || !awsSecretAccessKey || !s3Bucket || !s3Region) {
      //   showError("S3 config incomplete");
      //   return;
      // }

      // TODO: 2. S3 ã¨ãƒ­ãƒ¼ã‚«ãƒ«ã‚’åŒæœŸã™ã‚‹
      // const s3Client = new S3Client({ region: s3Region, credentials: { accessKeyId: awsAccessKeyId, secretAccessKey: awsSecretAccessKey } });
      // const provider: IStorageProvider = new S3StorageProvider(s3Client, s3Bucket, "files");
      // await provider.sync();
      // showInfo("Rsync-like sync completed.");

      // 3. ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›´æ–°ã—ãŸã„å ´åˆ (ä¾‹):
      //    ä¾‹ã¨ã—ã¦ã€Œãƒ­ãƒ¼ã‚«ãƒ«ã«ã‚ã‚‹æœ€æ–°Indexã«å¤‰æ›´ãŒã‚ã‚Œã°ã€æ–°ã—ã„index-xxx.jsonã‚’ä½œã‚‹ã€
      const latestIndex = await LocalObjectManager.loadLatestLocalIndex(options);
      const previousIndex = await LocalObjectManager.loadPreviousIndex(options);
      const localIndex = await LocalObjectManager.generateLocalIndexFile(previousIndex, options);
      const conflicts = LocalObjectManager.detectConflicts(localIndex, latestIndex);
      if (conflicts.length > 0) {
        const conflictsResolved = await LocalObjectManager.resolveConflicts(conflicts, options);
        if (!conflictsResolved) {
          showInfo("Sync aborted due to unresolved conflicts.");
          return true;
        }
      }

      // 7. æ–°è¦ã¾ãŸã¯å¤‰æ›´ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’ S3 ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
      const updated = await LocalObjectManager.saveEncryptedObject(localIndex.files, latestIndex, options);

      if (!updated) {
        showInfo("There are no update files.");
        return;
      }

      // 8. ãƒ­ãƒ¼ã‚«ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›´æ–°
      const newIndex = LocalObjectManager.createNewIndexFile(localIndex, previousIndex);
      showInfo("New local index file created.");
      LocalObjectManager.saveLocalIndexFile(newIndex);
    } catch (error: any) {
      showError(`Sync failed: ${error.message}`);
    }
    return true;
  });

  context.subscriptions.push(syncCommand, setAESKeyCommand, generateAESKeyCommand);
  outputChannel.show(true);
}

export function deactivate() {
  logMessage(`${appName} Extension Deactivated.`);
}
### End of src/extension.ts ###

### Start of src/logger.ts ###
import * as vscode from "vscode";

let outputChannel: vscode.OutputChannel;

export function setOutputChannel(channel: vscode.OutputChannel) {
  outputChannel = channel;
}

// Log message to output channel
export function logMessage(message: string) {
  outputChannel.appendLine(message);
}

// Show error message and log
export function showError(message: string) {
  vscode.window.showErrorMessage(message);
  logMessage(message);
}

// Show info message and log
export function showInfo(message: string) {
  vscode.window.showInformationMessage(message);
  logMessage(message);
}

### End of src/logger.ts ###

### Start of src/secretManager.ts ###
import * as vscode from "vscode";
import { showInfo, showError } from "./logger";

// Command to set secrets (AES Key or AWS Secret Access Key)
export async function setSecret(
  context: vscode.ExtensionContext,
  secretName: string,
  prompt: string,
  password: boolean = false,
  validate?: (value: string) => string | null
) {
  const secretValue = await vscode.window.showInputBox({
    prompt,
    password,
    validateInput: validate,
  });

  if (secretValue) {
    await context.secrets.store(secretName, secretValue);
    showInfo(`${secretName} saved successfully.`);
  } else {
    showError(`${secretName} is required.`);
  }
}

export async function getSecret(
  context: vscode.ExtensionContext,
  secretName: string
): Promise<string> {
  const aesEncryptionKey = (await context.secrets.get("aesEncryptionKey"))!;
  if (!aesEncryptionKey) {
    throw new Error("AES key not set. Please set the AES key first.");
  }
  return aesEncryptionKey;
}
### End of src/secretManager.ts ###

### Start of src/types.ts ###
// ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã‚’ä¿æŒã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
export interface FileEntry {
    path: string; // ãƒ•ã‚¡ã‚¤ãƒ«ã®ç›¸å¯¾ãƒ‘ã‚¹
    hash: string; // ãƒ•ã‚¡ã‚¤ãƒ«ã®SHA-256ãƒãƒƒã‚·ãƒ¥å€¤ï¼ˆæš—å·åŒ–å‰ã®ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦è¨ˆç®—ï¼‰
    timestamp: number; // ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€çµ‚æ›´æ–°ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
}

// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã®æ§‹é€ 
export interface IndexFile {
    uuid: string; // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã®UUIDï¼ˆVersion 7ï¼‰
    environmentId: string; // è¿½åŠ 
    parentUuid: string; // è¦ªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã®UUID
    files: FileEntry[]; // ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã®ãƒªã‚¹ãƒˆ
    timestamp: number; // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
}

// ç«¶åˆæƒ…å ±ã‚’ä¿æŒã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
export interface Conflict {
    filePath: string; // ç«¶åˆã—ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
    localHash: string; // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚·ãƒ¥å€¤
    remoteHash: string; // ãƒªãƒ¢ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚·ãƒ¥å€¤
    localTimestamp: number; // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
    remoteTimestamp: number; // ãƒªãƒ¢ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
}
export type LocalObjectManagerOptions = {
    environmentId: string;
    encryptionKey: string;
};
### End of src/types.ts ###

### Start of src/storage/IStorageProvider.ts ###
// src/IStorageProvider.ts
export interface IStorageProvider {
    /**
     * rsync çš„ãªåŒæ–¹å‘ã®ãƒ•ã‚¡ã‚¤ãƒ«åŒæœŸã‚’è¡Œã†
     *  - ãƒ­ãƒ¼ã‚«ãƒ«ã® .enc ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¯ãƒ©ã‚¦ãƒ‰ã¸
     *  - ã‚¯ãƒ©ã‚¦ãƒ‰ã«ã—ã‹ãªã„ .enc ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã¸
     */
    sync(): Promise<void>;
}

### End of src/storage/IStorageProvider.ts ###

### Start of src/storage/LocalObjectManager.ts ###
// src/LocalObjectManager.ts
import * as vscode from "vscode";
import * as crypto from "crypto";
import { logMessage } from "../logger";
import { IndexFile, FileEntry, Conflict, LocalObjectManagerOptions } from "../types";
import { v7 as uuidv7 } from 'uuid';

const secureNotesDir = ".secureNotes";
const indexDirName = "indexes";
const filesDirName = "files";
const previousIndexIDFilename = "index";
const rootUri = getRootUri();
const secureNootesUri = vscode.Uri.joinPath(rootUri, secureNotesDir);
const indexDirUri = vscode.Uri.joinPath(secureNootesUri, indexDirName);
const filesDirUri = vscode.Uri.joinPath(secureNootesUri, filesDirName);
const previousIndexIDUri = vscode.Uri.joinPath(secureNootesUri, previousIndexIDFilename);

interface FileIndex {
    originalFile: string;
    encryptedFile: string;
}

// ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ãƒ•ã‚©ãƒ«ãƒ€ã‚’å–å¾—
function getRootUri(): vscode.Uri {
    const workspaceUri = vscode.workspace.workspaceFolders ? vscode.workspace.workspaceFolders[0].uri : undefined;
    if (!workspaceUri) {
        throw new Error("No workspace folder found.");
    }
    return workspaceUri;
}

export class LocalObjectManager {
    /**
     * ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹å†…ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æš—å·åŒ–ã—ã€.secureNotes ã«ä¿å­˜
     */
    public static async saveEncryptedObject(
        localFiles: FileEntry[],
        latestIndex: IndexFile,
        options: LocalObjectManagerOptions
    ): Promise<boolean> {
        // ãƒªãƒ¢ãƒ¼ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚·ãƒ¥å€¤ã®ã‚»ãƒƒãƒˆã‚’ä½œæˆ
        const latestFileHashes = new Set(latestIndex.files.map((file) => file.hash));
        let updated = false;
        for (const file of localFiles) {
            // ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒªãƒ¢ãƒ¼ãƒˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
            if (latestFileHashes.has(file.hash)) {
                continue; // æ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆã€ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒƒãƒ—
            }
            // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
            const fileUri = vscode.Uri.joinPath(rootUri, file.path);
            const fileContent = await vscode.workspace.fs.readFile(fileUri);

            // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æš—å·åŒ–
            const encryptedContent = this.encryptContent(Buffer.from(fileContent), options.encryptionKey);

            // objects directory ã«ä¿å­˜
            const encryptedFileName = vscode.Uri.joinPath(filesDirUri, file.hash);
            await vscode.workspace.fs.writeFile(encryptedFileName, encryptedContent);
            logMessage(`save file:${file.path}, to:${encryptedFileName.path}`);
            updated = true;
        }
        return updated;
    }

    /**
     * ãƒ­ãƒ¼ã‚«ãƒ« .secureNotes/indexes ã«ã‚ã‚‹ã™ã¹ã¦ã® index-<UUID>.json ã®ãƒ‘ã‚¹ä¸€è¦§
     */
    public static async listLocalIndexFiles(): Promise<string[]> {
        // .secureNotes/indexes ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ç©ºé…åˆ—ã‚’è¿”ã™
        try {
            await vscode.workspace.fs.stat(indexDirUri);
        } catch (error) {
            return [];
        }
        const dirs = await vscode.workspace.fs.readDirectory(indexDirUri);
        return dirs.filter(
            (f) => f[1] === vscode.FileType.File
                && f[0].startsWith("index-")
                && f[0].endsWith(".json")
        ).map((f) => f[0]);
    }

    /**
     * ãƒ­ãƒ¼ã‚«ãƒ«ã«ã‚ã‚‹ã†ã¡ã€ã‚‚ã£ã¨ã‚‚æ–°ã—ã„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
     */
    public static async loadLatestLocalIndex(options: LocalObjectManagerOptions): Promise<IndexFile> {
        const indexFiles = await this.listLocalIndexFiles();
        if (indexFiles.length === 0) {
            // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯æ–°è¦ä½œæˆ
            return {
                uuid: uuidv7(),
                parentUuid: "",
                environmentId: options.environmentId,
                files: [],
                timestamp: 0,
            };
        }

        // 1) ãƒ•ã‚¡ã‚¤ãƒ«åï¼ˆbasenameï¼‰ã‚’æŠ½å‡ºã—ã¦ã‚½ãƒ¼ãƒˆï¼ˆé™é †ï¼‰
        //    "index-017f8d3f-e23c-7aa6-85f8-fc1855b36328.json" ã®æ¯”è¼ƒã§ã€
        //    UUIDv7éƒ¨åˆ†ã‚’å«ã‚€æ–‡å­—åˆ—ã‚’æ¯”è¼ƒã™ã‚‹
        indexFiles.sort((a, b) => {
            // é™é †ãªã®ã§Bâ†’Aã®é †ã§è¿”ã™
            if (a < b) { return 1; }
            if (a > b) { return -1; }
            return 0;
        });

        // 2) å…ˆé ­(æœ€ã‚‚æ–°ã—ã„=ä¸€ç•ªå¤§ãã„UUIDv7)ã‚’èª­ã¿è¾¼ã‚€
        const latestFilePath = indexFiles[0];
        const latestIndexFileUri = vscode.Uri.joinPath(indexDirUri, latestFilePath);
        const content = await vscode.workspace.fs.readFile(latestIndexFileUri);
        return JSON.parse(content.toString()) as IndexFile;
    }

    // å‰å›ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€é–¢æ•°
    public static async loadPreviousIndex(options: LocalObjectManagerOptions): Promise<IndexFile> {
        try {
            const indexContent = await vscode.workspace.fs.readFile(previousIndexIDUri);
            const index = await vscode.workspace.fs.readFile(vscode.Uri.joinPath(indexDirUri, indexContent.toString()));
            return JSON.parse(index.toString());
        } catch (error) {
            // ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã‚„èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯æ–°è¦ä½œæˆ
            return {
                uuid: uuidv7(),
                parentUuid: "",
                environmentId: options.environmentId,
                files: [],
                timestamp: 0,
            };
        }
    }

    /**
     * æ–°ã—ã„ index-<UUID>.json ã‚’ä½œæˆã—ä¿å­˜
     */
    public static createNewIndexFile(localIndex: IndexFile, previousIndex: IndexFile): IndexFile {
        const newUUID = uuidv7();
        const newIndexFile: IndexFile = {
            uuid: newUUID,
            parentUuid: previousIndex.uuid,
            environmentId: localIndex.environmentId,
            files: localIndex.files,
            timestamp: Date.now(),
        };

        return newIndexFile;
    }
    /*
        vscode.workspace.fs.createDirectory(filesDirUri);
        const fileUri = vscode.Uri.joinPath(indexDirUri, `index-${newUUID}.json`);
        const encryptedIndex = this.encryptContent(Buffer.from(JSON.stringify(newIndex, null, 2)), options.encryptionKey);
        vscode.workspace.fs.writeFile(fileUri, encryptedIndex);
        */



    /**
     * AES-256-CBC ã§æš—å·åŒ–
     */
    private static encryptContent(content: Buffer, key: string): Buffer {
        const iv = crypto.randomBytes(16);
        const keyBuffer = Buffer.from(key, "hex");
        const cipher = crypto.createCipheriv("aes-256-cbc", keyBuffer, iv);
        const encrypted = Buffer.concat([cipher.update(content), cipher.final()]);
        return Buffer.concat([iv, encrypted]);
    }

    /**
     * AES-256-CBC ã§å¾©å·
     */
    private static decryptContent(encryptedContent: Buffer, key: string): Buffer {
        const iv = encryptedContent.subarray(0, 16);
        const encryptedText = encryptedContent.subarray(16);
        const keyBuffer = Buffer.from(key, "hex");
        const decipher = crypto.createDecipheriv("aes-256-cbc", keyBuffer, iv);
        return Buffer.concat([decipher.update(encryptedText), decipher.final()]);
    }

    // å¾©å·åŒ–ã—ãŸå†…å®¹ã‚’è¿”ã™å…±é€šé–¢æ•°
    private static async decryptFileFromLocalObject(fileHash: string, options: LocalObjectManagerOptions): Promise<Uint8Array> {
        const filePath = vscode.Uri.joinPath(filesDirUri, fileHash);
        const content = await vscode.workspace.fs.readFile(filePath);
        try {
            return this.decryptContent(Buffer.from(content), options.encryptionKey);
        } catch (error: any) {
            logMessage(`Failed to fetch or decrypt file: ${fileHash}.Error: ${error.message} `);
            throw error;
        }
    }
    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—ã—ã€ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã«ä¿å­˜ã™ã‚‹å…±é€šé–¢æ•°
    private static async fetchDecryptAndSaveFile(
        filePath: string,
        fileHash: string,
        options: LocalObjectManagerOptions,
        conflictFileName?: string,
    ): Promise<void> {
        try {
            const decryptedContent = await this.decryptFileFromLocalObject(fileHash, options);
            const savePath = conflictFileName ? conflictFileName : filePath;

            // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’å–å¾—
            const localUri = vscode.Uri.joinPath(vscode.Uri.file(rootUri.fsPath), savePath);

            // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
            await vscode.workspace.fs.writeFile(localUri, decryptedContent);
            logMessage(`Saved remote file to local path: ${savePath} `);
        } catch (error: any) {
            logMessage(`Failed to save remote file to local path: ${filePath}.Error: ${error.message} `);
            throw error;
        }
    }
    // ãƒªãƒ¢ãƒ¼ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã§ãƒ­ãƒ¼ã‚«ãƒ«ã‚’ä¸Šæ›¸ã
    private static async overwriteLocalFileWithRemote(
        filePath: string,
        fileHash: string,
        options: LocalObjectManagerOptions,
    ): Promise<void> {
        await this.fetchDecryptAndSaveFile(filePath, fileHash, options);
        logMessage(`Overwrote local file with remote content: ${filePath} `);
    }
    // ãƒªãƒ¢ãƒ¼ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ¥åã§ä¿å­˜
    public static async saveRemoteFileAsConflict(
        filePath: string,
        fileHash: string,
        options: LocalObjectManagerOptions
    ): Promise<void> {
        // ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆç”¨ã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆï¼ˆä¾‹: conflict-YYYYMMDD-HHmmss-ãƒ•ã‚¡ã‚¤ãƒ«å.extï¼‰
        const timestamp = new Date().toISOString().replace(/[:.]/g, "-").replace("T", "_").split("Z")[0];
        const conflictFileName = `conflict - ${timestamp} -${filePath} `;
        await this.fetchDecryptAndSaveFile(filePath, fileHash, options, conflictFileName);
        logMessage(`Saved remote file as conflict file: ${conflictFileName} `);
    }

    // æ¤œå‡ºã•ã‚ŒãŸç«¶åˆã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€šçŸ¥ã—ã€è§£æ±ºã—ã¾ã™ã€‚
    public static async resolveConflicts(
        conflicts: Conflict[],
        options: LocalObjectManagerOptions
    ): Promise<boolean> {
        for (const conflict of conflicts) {
            if (conflict.localHash.length === 0) {
                logMessage(`Remote only file: ${conflict.filePath} `);
                await this.fetchDecryptAndSaveFile(conflict.filePath, conflict.remoteHash, options);
                continue;
            }
            const choice = await vscode.window.showQuickPick(
                ["Keep Local Version", "Keep Remote Version", "Save Remote as Conflict File", "Abort Sync"],
                {
                    placeHolder: `Conflict detected in file: ${conflict.filePath} `,
                }
            );

            if (choice === "Keep Local Version") {
                // ãƒ­ãƒ¼ã‚«ãƒ«ã®å¤‰æ›´ã‚’é©ç”¨ï¼ˆä½•ã‚‚ã—ãªã„ï¼‰
                continue;
            } else if (choice === "Keep Remote Version") {
                // ãƒªãƒ¢ãƒ¼ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã§ãƒ­ãƒ¼ã‚«ãƒ«ã‚’ä¸Šæ›¸ã
                await this.overwriteLocalFileWithRemote(conflict.filePath, conflict.remoteHash, options);
            } else if (choice === "Save Remote as Conflict File") {
                // ãƒªãƒ¢ãƒ¼ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ¥åã§ä¿å­˜
                await this.saveRemoteFileAsConflict(conflict.filePath, conflict.remoteHash, options);
            } else if (choice === "Abort Sync" || !choice) {
                // åŒæœŸã‚’ä¸­æ­¢
                return false;
            }
        }
        return true;
    }
    // ãƒ­ãƒ¼ã‚«ãƒ«ã¨ãƒªãƒ¢ãƒ¼ãƒˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¯”è¼ƒã—ã€ç«¶åˆã‚’æ¤œå‡ºã—ã¾ã™ã€‚
    public static detectConflicts(localIndex: IndexFile, remoteIndex: IndexFile): Conflict[] {
        const conflicts: Conflict[] = [];

        // ãƒªãƒ¢ãƒ¼ãƒˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ UUID ã¨ãƒ­ãƒ¼ã‚«ãƒ«ã® parentUuid ã‚’æ¯”è¼ƒ
        if (remoteIndex.uuid === localIndex.parentUuid) {
            // ãƒªãƒ¢ãƒ¼ãƒˆã«å¤‰æ›´ãŒãªã„ãŸã‚ã€ç«¶åˆãªã—
            return conflicts;
        }

        // ãƒªãƒ¢ãƒ¼ãƒˆã«å¤‰æ›´ãŒã‚ã‚‹å ´åˆã®ã¿ç«¶åˆã‚’æ¤œå‡º
        const remoteFileMap = new Map<string, FileEntry>();
        for (const file of remoteIndex.files) {
            remoteFileMap.set(file.path, file);
        }

        for (const localFile of localIndex.files) {
            const remoteFile = remoteFileMap.get(localFile.path);
            if (remoteFile) {
                if (localFile.hash !== remoteFile.hash) {
                    // ãƒãƒƒã‚·ãƒ¥å€¤ãŒç•°ãªã‚‹å ´åˆã€ç«¶åˆã¨åˆ¤æ–­
                    conflicts.push({
                        filePath: localFile.path,
                        localHash: localFile.hash,
                        remoteHash: remoteFile.hash,
                        localTimestamp: localFile.timestamp,
                        remoteTimestamp: remoteFile.timestamp,
                    });
                }
                // æ¯”è¼ƒå¾Œã«å‰Šé™¤
                remoteFileMap.delete(localFile.path);
            }
        }

        // ãƒ­ãƒ¼ã‚«ãƒ«ã«å­˜åœ¨ã›ãšã€ãƒªãƒ¢ãƒ¼ãƒˆã«å­˜åœ¨ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚‚è€ƒæ…®
        for (const remoteFile of remoteFileMap.values()) {
            conflicts.push({
                filePath: remoteFile.path,
                localHash: "",
                remoteHash: remoteFile.hash,
                localTimestamp: 0,
                remoteTimestamp: remoteFile.timestamp,
            });
        }

        return conflicts;
    }
    // ãƒ­ãƒ¼ã‚«ãƒ«ã®ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã€ãƒãƒƒã‚·ãƒ¥å€¤ã€ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å–å¾—ã—ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
    static async generateLocalIndexFile(previousIndex: IndexFile, options: LocalObjectManagerOptions): Promise<IndexFile> {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            throw new Error("No workspace folders found.");
        }

        const files: FileEntry[] = [];
        const previousFileMap = new Map<string, FileEntry>();
        if (previousIndex) {
            // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’ã‚­ãƒ¼ã«ã—ã¦ãƒãƒƒãƒ—ã«ä¿å­˜
            for (const file of previousIndex.files) {
                previousFileMap.set(file.path, file);
            }
        }

        for (const folder of workspaceFolders) {
            const filesInFolder = await vscode.workspace.findFiles(
                new vscode.RelativePattern(folder, "**/*"),
                `{**/node_modules/**,${secureNotesDir}/**}`
            );

            for (const fileUri of filesInFolder) {
                const stat = await vscode.workspace.fs.stat(fileUri);
                const relativePath = vscode.workspace.asRelativePath(fileUri, false);

                // å‰å›ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«åŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹ã‹ç¢ºèª
                const previousFileEntry = previousFileMap.get(relativePath);

                if (previousFileEntry && previousFileEntry.timestamp === stat.mtime) {
                    // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãŒåŒã˜å ´åˆã€ãƒãƒƒã‚·ãƒ¥å€¤ã‚’å†åˆ©ç”¨
                    files.push({
                        path: relativePath,
                        hash: previousFileEntry.hash,
                        timestamp: stat.mtime,
                    });
                } else {
                    // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãŒç•°ãªã‚‹å ´åˆã€ãƒãƒƒã‚·ãƒ¥å€¤ã‚’å†è¨ˆç®—
                    const fileContent = await vscode.workspace.fs.readFile(fileUri);
                    const hash = crypto.createHash("sha256").update(fileContent).digest("hex");

                    files.push({
                        path: relativePath,
                        hash: hash,
                        timestamp: stat.mtime,
                    });
                }
            }
        }

        const indexFile: IndexFile = {
            uuid: uuidv7(),
            parentUuid: previousIndex.uuid, // ã“ã“ã§ãƒªãƒ¢ãƒ¼ãƒˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ UUID ã‚’è¨­å®š
            environmentId: options.environmentId,
            files: files,
            timestamp: Date.now(),
        };


        return indexFile;
    }
    // æ–°ã—ã„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã«ä¿å­˜ã™ã‚‹é–¢æ•°
    public static async saveLocalIndexFile(indexFile: IndexFile): Promise<void> {
        await vscode.workspace.fs.createDirectory(indexDirUri);
        const indexContent = Buffer.from(JSON.stringify(indexFile, null, 2), "utf-8");
        const indexFileName = `index-${indexFile.uuid}.json`;
        const indexFilePath = vscode.Uri.joinPath(indexDirUri, indexFileName);
        await vscode.workspace.fs.writeFile(indexFilePath, indexContent);
        await vscode.workspace.fs.writeFile(previousIndexIDUri, Buffer.from(indexFileName));
    }
}

### End of src/storage/LocalObjectManager.ts ###

