### Start of webpack.config.js ###
//@ts-check

'use strict';

const path = require('path');

//@ts-check
/** @typedef {import('webpack').Configuration} WebpackConfig **/

/** @type WebpackConfig */
const extensionConfig = {
  target: 'node', // VS Code extensions run in a Node.js-context ğŸ“– -> https://webpack.js.org/configuration/node/
	mode: 'none', // this leaves the source code as close as possible to the original (when packaging we set this to 'production')

  entry: './src/extension.ts', // the entry point of this extension, ğŸ“– -> https://webpack.js.org/configuration/entry-context/
  output: {
    // the bundle is stored in the 'dist' folder (check package.json), ğŸ“– -> https://webpack.js.org/configuration/output/
    path: path.resolve(__dirname, 'dist'),
    filename: 'extension.js',
    libraryTarget: 'commonjs2'
  },
  externals: {
    vscode: 'commonjs vscode' // the vscode-module is created on-the-fly and must be excluded. Add other modules that cannot be webpack'ed, ğŸ“– -> https://webpack.js.org/configuration/externals/
    // modules added here also need to be added in the .vscodeignore file
  },
  resolve: {
    // support reading TypeScript and JavaScript files, ğŸ“– -> https://github.com/TypeStrong/ts-loader
    extensions: ['.ts', '.js']
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        exclude: /node_modules/,
        use: [
          {
            loader: 'ts-loader'
          }
        ]
      }
    ]
  },
  devtool: 'nosources-source-map',
  infrastructureLogging: {
    level: "log", // enables logging required for problem matchers
  },
};
module.exports = [ extensionConfig ];
### End of webpack.config.js ###

### Start of package.json ###
{
  "name": "secure-notes-sync",
  "displayName": "Secure Notes Sync",
  "description": "A VS Code extension for securely syncing notes with AWS S3 using AES encryption.",
  "version": "0.0.1",
  "publisher": "Masahide YAMASAKI",
  "engines": {
    "vscode": "^1.96.0"
  },
  "categories": [
    "Other"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/masahide/SecureNotesSyncVSCodeExt.git"
  },
  "main": "./dist/extension.js",
  "activationEvents": [
    "workspaceContains:.secureNotes/index"
  ],
  "contributes": {
    "configuration": {
      "type": "object",
      "title": "Secure Notes Sync",
      "properties": {
        "SecureNotesSync.awsAccessKeyId": {
          "type": "string",
          "description": "AWS Access Key ID for S3",
          "default": ""
        },
        "SecureNotesSync.s3Bucket": {
          "type": "string",
          "description": "S3 Bucket Name",
          "default": ""
        },
        "SecureNotesSync.s3Region": {
          "type": "string",
          "description": "S3 Region",
          "default": ""
        },
        "SecureNotesSync.s3Endpoint": {
          "type": "string",
          "description": "S3 Custom Endpoint (optional)",
          "default": ""
        },
        "SecureNotesSync.s3PrefixPath": {
          "type": "string",
          "description": "S3 Prefix Path (optional)",
          "default": ""
        },
        "SecureNotesSync.gitRemoteUrl": {
          "type": "string",
          "description": "GitHub repository URL for syncing the object directory. (ex: git@github.com:user/repo.git)",
          "default": "git@github.com:user/repo.git"
        },
        "SecureNotesSync.enableAutoSync": {
          "type": "boolean",
          "description": "Enable auto sync on save",
          "default": false
        },
        "SecureNotesSync.inactivityTimeoutSec": {
          "type": "number",
          "description": "Inactivity timeout in seconds for auto sync",
          "default": 60
        }
      }
    },
    "commands": [
      {
        "command": "extension.setAWSSecret",
        "title": "Set AWS secret access key"
      },
      {
        "command": "extension.setAESKey",
        "title": "Set AES encryption Key"
      },
      {
        "command": "extension.generateAESKey",
        "title": "Generate AES Key"
      },
      {
        "command": "extension.syncNotes",
        "title": "Sync Notes"
      },
      {
        "command": "extension.syncWithGitHub",
        "title": "Sync with GitHub"
      }
    ]
  },
  "scripts": {
    "vscode:prepublish": "npm run package",
    "compile": "webpack",
    "watch": "webpack --watch",
    "package": "webpack --mode production --devtool hidden-source-map",
    "compile-tests": "tsc -p . --outDir out",
    "watch-tests": "tsc -p . -w --outDir out",
    "pretest": "npm run compile-tests && npm run compile && npm run lint",
    "lint": "eslint src",
    "test": "vscode-test"
  },
  "devDependencies": {
    "@types/mocha": "^10.0.10",
    "@types/node": "22.x",
    "@types/vscode": "^1.96.0",
    "@types/which": "^3.0.4",
    "@typescript-eslint/eslint-plugin": "^8.19.0",
    "@typescript-eslint/parser": "^8.19.0",
    "@vscode/test-cli": "^0.0.10",
    "@vscode/test-electron": "^2.4.1",
    "aws-sdk": "^2.1692.0",
    "eslint": "^9.17.0",
    "ts-loader": "^9.5.1",
    "typescript": "^5.7.2",
    "webpack": "^5.97.1",
    "webpack-cli": "^6.0.1"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.722.0",
    "uuid": "^11.0.3",
    "which": "^5.0.0"
  }
}

### End of package.json ###

### Start of src/extension.ts ###
import * as vscode from "vscode";
import * as os from "os";
import { logMessage, showInfo, showError, setOutputChannel } from "./logger";
import { setSecret } from "./secretManager";
import { LocalObjectManager } from "./storage/LocalObjectManager";
import { GitHubSyncProvider } from "./storage/GithubProvider";
import * as crypto from "crypto";


const aesEncryptionKey = "aesEncryptionKey";
const appName = "SecureNotesSync";

// ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆIDã‚’ä¿æŒã™ã‚‹å¤‰æ•°
let inactivityTimeout: NodeJS.Timeout | undefined;

// éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹é–¢æ•°
function resetInactivityTimer() {
  if (inactivityTimeout) {
    clearTimeout(inactivityTimeout);
  }
  const inactivityTimeoutSec = vscode.workspace.getConfiguration(appName).get<number>('inactivityTimeoutSec');
  if (inactivityTimeoutSec === undefined) {
    return;
  }
  inactivityTimeout = setTimeout(() => {
    // éã‚¢ã‚¯ãƒ†ã‚£ãƒ–æœŸé–“ãŒçµŒéã—ãŸã‚‰åŒæœŸã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ
    vscode.commands.executeCommand("extension.syncNotes");
    vscode.commands.executeCommand("extension.syncWithGitHub");
    logMessage("éã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ãŒç¶šã„ãŸãŸã‚ã€åŒæœŸã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã—ãŸã€‚");
  }, inactivityTimeoutSec * 1000);
}

// è¨­å®šã‚’ç¢ºèªã—ã€ã‚¿ã‚¤ãƒãƒ¼ã‚’é–‹å§‹ã¾ãŸã¯åœæ­¢ã™ã‚‹é–¢æ•°
function manageInactivityTimer() {
  const isAutoSyncEnabled = vscode.workspace.getConfiguration(appName).get<boolean>("enableAutoSync", false);
  if (isAutoSyncEnabled) {
    // è¨­å®šãŒæœ‰åŠ¹ãªå ´åˆã€ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
    resetInactivityTimer();
    logMessage("è‡ªå‹•åŒæœŸãŒæœ‰åŠ¹ã§ã™ã€‚éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¿ã‚¤ãƒãƒ¼ã‚’é–‹å§‹ã—ã¾ã™ã€‚");
  } else {
    // è¨­å®šãŒç„¡åŠ¹ãªå ´åˆã€ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢
    if (inactivityTimeout) {
      clearTimeout(inactivityTimeout);
      inactivityTimeout = undefined;
      //logMessage("è‡ªå‹•åŒæœŸãŒç„¡åŠ¹ã§ã™ã€‚éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¿ã‚¤ãƒãƒ¼ã‚’åœæ­¢ã—ã¾ã™ã€‚");
    }
  }
}

export async function activate(context: vscode.ExtensionContext) {
  // Create output channel
  const outputChannel = vscode.window.createOutputChannel(appName);
  setOutputChannel(outputChannel);
  showInfo(`${appName} Extension Activated`);

  // ç’°å¢ƒIDã‚’ç”Ÿæˆorå–å¾— (ãƒ›ã‚¹ãƒˆå + UUID)
  const environmentId = await getOrCreateEnvironmentId(context);
  logMessage(`Current Environment ID: ${environmentId}`);

  // Command to Set AES Key
  let setAESKeyCommand = vscode.commands.registerCommand("extension.setAESKey", () =>
    setSecret(context,
      aesEncryptionKey,
      "Enter AES Encryption Key (64 hex characters representing 32 bytes)",
      true,
      (value) => value.length === 64 ? null : "AES Key must be 64 hex characters long"
    )
  );

  // Command to Generate 32-Byte Encrypted Text
  let generateAESKeyCommand = vscode.commands.registerCommand("extension.generateAESKey", async () => {
    logMessage("Generating 32-byte AES encryption key...");
    const key = crypto.randomBytes(32).toString("hex"); // 32 bytes
    try {
      await context.secrets.store("aesEncryptionKey", key);
      showInfo(`Generated and stored AES key: ${key}`);
    } catch (error: any) {
      showError(`Error generating encrypted text: ${error instanceof Error ? error.message : String(error)}`);
    }
  });

  let syncCommand = vscode.commands.registerCommand("extension.syncNotes", async () => {
    try {
      const encryptKey = await context.secrets.get(aesEncryptionKey);
      if (!encryptKey) {
        showError("AES Key not set");
        return false;
      }
      const config = vscode.workspace.getConfiguration(appName);
      const options = { environmentId: environmentId, encryptionKey: encryptKey };
      const latestIndex = await LocalObjectManager.loadLatestLocalIndex(options);
      const previousIndex = await LocalObjectManager.loadPreviousIndex(options);
      logMessage(`Loaded latest index file: ${latestIndex.uuid}\n previous index file: ${previousIndex.uuid}`);
      const localIndex = await LocalObjectManager.generateLocalIndexFile(previousIndex, options);
      const conflicts = LocalObjectManager.detectConflicts(localIndex, latestIndex);
      if (conflicts.length > 0) {
        const conflictsResolved = await LocalObjectManager.resolveConflicts(conflicts, options);
        if (!conflictsResolved) {
          showInfo("Sync aborted due to unresolved conflicts.");
          return true;
        }
      }

      const updated = await LocalObjectManager.saveEncryptedObject(localIndex.files, latestIndex, options);
      if (!updated) {
        showInfo("There are no update files.");
        return;
      }

      const newIndex = LocalObjectManager.createNewIndexFile(localIndex, previousIndex);
      showInfo("New local index file created.");
      LocalObjectManager.saveLocalIndexFile(newIndex, options);
    } catch (error: any) {
      showError(`Sync failed: ${error.message}`);
    }
    return true;
  });

  let syncWithGitHubCommand = vscode.commands.registerCommand("extension.syncWithGitHub", async () => {
    try {
      const gitRemoteUrl = vscode.workspace.getConfiguration(appName).get<string>('gitRemoteUrl');
      if (!gitRemoteUrl) {
        showError("è¨­å®šã§GitHubãƒªãƒã‚¸ãƒˆãƒªURLã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚");
        return;
      }
      const cloudStorageProvider = new GitHubSyncProvider(gitRemoteUrl);
      cloudStorageProvider.sync();
    } catch (error: any) {
      showError(`Cloud sync failed: ${error.message}`);
    }
  });

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’ç™»éŒ²
  const userActivityEvents = [
    vscode.window.onDidChangeActiveTextEditor,
    vscode.workspace.onDidChangeTextDocument,
    vscode.workspace.onDidSaveTextDocument,
    vscode.window.onDidChangeVisibleTextEditors,
    vscode.window.onDidChangeActiveNotebookEditor,
    vscode.window.onDidChangeActiveTerminal,
    vscode.window.onDidChangeWindowState,
  ];

  // ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç›£è¦–ã—ã€ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ãŒã‚ã£ãŸã‚‰ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
  const disposables = userActivityEvents.map(event => event(() => {
    if (vscode.workspace.getConfiguration(appName).get<boolean>("enableAutoSync", false)) {
      resetInactivityTimer();
    }
  }));

  // è¨­å®šå¤‰æ›´ã‚’ç›£è¦–ã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const configChangeDisposable = vscode.workspace.onDidChangeConfiguration((e) => {
    if (e.affectsConfiguration(`${appName}.enableAutoSync`)) {
      manageInactivityTimer();
    }
  });

  // åˆæœŸçŠ¶æ…‹ã§ã‚¿ã‚¤ãƒãƒ¼ã‚’ç®¡ç†
  manageInactivityTimer();

  context.subscriptions.push(
    syncCommand, setAESKeyCommand, generateAESKeyCommand, syncWithGitHubCommand,
    configChangeDisposable,
    ...disposables
  );
  outputChannel.show(true);
}

export function deactivate() {
  if (inactivityTimeout) {
    clearTimeout(inactivityTimeout);
  }
  logMessage(`${appName} Extension Deactivated.`);
}


const ENV_ID_KEY = "encryptSyncEnvironmentId";
async function getOrCreateEnvironmentId(context: vscode.ExtensionContext): Promise<string> {
  let envId = context.globalState.get<string>(ENV_ID_KEY);
  if (!envId) {
    const hostname = os.hostname();
    envId = `${hostname}-${crypto.randomUUID()}`;
    await context.globalState.update(ENV_ID_KEY, envId);
  }
  return envId;
}

### End of src/extension.ts ###

### Start of src/logger.ts ###
import * as vscode from "vscode";

let outputChannel: vscode.OutputChannel;

export function setOutputChannel(channel: vscode.OutputChannel) {
  outputChannel = channel;
}

// Log message to output channel
export function logMessage(message: string) {
  outputChannel.appendLine(message);
}

// Show error message and log
export function showError(message: string) {
  vscode.window.showErrorMessage(message);
  logMessage(message);
}

// Show info message and log
export function showInfo(message: string) {
  vscode.window.showInformationMessage(message);
  logMessage(message);
}

### End of src/logger.ts ###

### Start of src/secretManager.ts ###
import * as vscode from "vscode";
import { showInfo, showError } from "./logger";

// Command to set secrets (AES Key or AWS Secret Access Key)
export async function setSecret(
  context: vscode.ExtensionContext,
  secretName: string,
  prompt: string,
  password: boolean = false,
  validate?: (value: string) => string | null
) {
  const secretValue = await vscode.window.showInputBox({
    prompt,
    password,
    validateInput: validate,
  });

  if (secretValue) {
    await context.secrets.store(secretName, secretValue);
    showInfo(`${secretName} saved successfully.`);
  } else {
    showError(`${secretName} is required.`);
  }
}

export async function getSecret(
  context: vscode.ExtensionContext,
  secretName: string
): Promise<string> {
  const aesEncryptionKey = (await context.secrets.get("aesEncryptionKey"))!;
  if (!aesEncryptionKey) {
    throw new Error("AES key not set. Please set the AES key first.");
  }
  return aesEncryptionKey;
}
### End of src/secretManager.ts ###

### Start of src/types.ts ###
// ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã‚’ä¿æŒã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
export interface FileEntry {
    path: string; // ãƒ•ã‚¡ã‚¤ãƒ«ã®ç›¸å¯¾ãƒ‘ã‚¹
    hash: string; // ãƒ•ã‚¡ã‚¤ãƒ«ã®SHA-256ãƒãƒƒã‚·ãƒ¥å€¤ï¼ˆæš—å·åŒ–å‰ã®ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦è¨ˆç®—ï¼‰
    timestamp: number; // ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€çµ‚æ›´æ–°ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
    deleted?: boolean; // ãƒ•ã‚¡ã‚¤ãƒ«ãŒå‰Šé™¤ã•ã‚ŒãŸã‹ã©ã†ã‹
}

// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã®æ§‹é€ 
export interface IndexFile {
    uuid: string; // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã®UUIDï¼ˆVersion 7ï¼‰
    environmentId: string; // è¿½åŠ 
    parentUuid: string; // è¦ªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã®UUID
    files: FileEntry[]; // ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã®ãƒªã‚¹ãƒˆ
    timestamp: number; // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
}

// ç«¶åˆæƒ…å ±ã‚’ä¿æŒã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
export interface Conflict {
    filePath: string; // ç«¶åˆã—ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
    localHash: string; // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚·ãƒ¥å€¤
    remoteHash: string; // ãƒªãƒ¢ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚·ãƒ¥å€¤
    localTimestamp: number; // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
    remoteTimestamp: number; // ãƒªãƒ¢ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
}
export type LocalObjectManagerOptions = {
    environmentId: string;
    encryptionKey: string;
};
### End of src/types.ts ###

### Start of src/storage/GithubProvider.ts ###
// storage/providers/GitHubSyncProvider.ts
import * as vscode from "vscode";
import { IStorageProvider } from './IStorageProvider';
import { objectDirUri } from './LocalObjectManager';
import { showError, logMessage } from '../logger';
import * as cp from 'child_process';
import which from 'which';
import * as fs from 'fs';

export class GitHubSyncProvider implements IStorageProvider {
    private gitRemoteUrl: string;
    private gitPath: string;

    constructor(gitRemoteUrl: string) {
        this.gitRemoteUrl = gitRemoteUrl;
        this.gitPath = findGitExecutable();
    }

    public async sync(): Promise<void> {
        logMessage(`gitPath: ${this.gitPath}`);
        try {
            const objectDir = objectDirUri.fsPath;
            // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒGitãƒªãƒã‚¸ãƒˆãƒªã‹ã©ã†ã‹ã‚’ç¢ºèª
            const isGitRepo = await this.isGitRepository(objectDir);
            if (!isGitRepo) {
                // Gitãƒªãƒã‚¸ãƒˆãƒªã‚’åˆæœŸåŒ–
                const gitattributesUri = vscode.Uri.joinPath(objectDirUri, '.gitattributes');
                await vscode.workspace.fs.writeFile(gitattributesUri, new TextEncoder().encode('* binary'));
                await this.execCmd(this.gitPath, ['init'], objectDir);
                await this.execCmd(this.gitPath, ['remote', 'add', 'origin', this.gitRemoteUrl], objectDir);
                await this.execCmd(this.gitPath, ['fetch', 'origin'], objectDir);
                // Check if 'main' branch exists on remote
                const checkMainBranch = await this.execCmd(this.gitPath, ['ls-remote', '--heads', 'origin', 'main'], objectDir);
                await this.execCmd(this.gitPath, ['add', '.'], objectDir);
                await this.execCmd(this.gitPath, ['commit', '-m', 'add'], objectDir);
                if (checkMainBranch.stdout.trim() === '') {
                    await this.execCmd(this.gitPath, ['branch', '-M', 'main'], objectDir);
                } else {
                    // å¼·åˆ¶çš„ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ãƒãƒ¼ã‚¸
                    await this.execCmd(this.gitPath, ['branch', '-M', 'backup'], objectDir);
                    await this.execCmd(this.gitPath, ['fetch', 'origin', 'main'], objectDir);
                    await this.execCmd(this.gitPath, ['checkout', 'main'], objectDir);
                    // å¼·åˆ¶ãƒãƒ¼ã‚¸
                    await this.execCmd(this.gitPath, ['merge', 'backup', '--allow-unrelated-histories', '-X', 'ours', '-m', 'merge'], objectDir);
                    await this.execCmd(this.gitPath, ['branch', '-D', 'backup'], objectDir);
                    logMessage("ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’GitHubã¨å¼·åˆ¶ãƒãƒ¼ã‚¸ã—ã¾ã—ãŸ");
                }
                await this.execCmd(this.gitPath, ['push', '-u', 'origin', 'main'], objectDir);
                logMessage("ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’GitHubã¨åŒæœŸã—ã¾ã—ãŸã€‚");
                return;
            }
            // ã™ã¹ã¦ã®å¤‰æ›´ã‚’ã‚³ãƒŸãƒƒãƒˆ
            await this.execCmd(this.gitPath, ['add', '.'], objectDir);
            try {
                await this.execCmd(this.gitPath, ['diff', '--cached', '--quiet'], objectDir);
                logMessage("å¤‰æ›´ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
                return;
            } catch { }
            await this.execCmd(this.gitPath, ['commit', '-m', 'sync'], objectDir);
            await this.execCmd(this.gitPath, ['push', 'origin', 'main'], objectDir);
            logMessage("ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’GitHubã¨åŒæœŸã—ã¾ã—ãŸã€‚");
        } catch (error) {
            showError(`sync GitHub error:${(error as Error).message}`);
        }
    }

    // Gitã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
    private async execCmd(cmd: string, args: string[], cwd: string): Promise<{ stdout: string, stderr: string }> {
        return new Promise((resolve, reject) => {
            cp.execFile(cmd, args, { cwd: cwd }, (error, stdout, stderr) => {
                if (error) {
                    reject(new Error(`execFile error: ${cwd}> ${cmd} ${args.join(' ')}\nstdout:'${stdout}', stderr:'${stderr}'`));
                } else {
                    logMessage(`execFile: ${cwd}> ${cmd} ${args.join(' ')}`);
                    if (stdout !== '') { logMessage(`${stdout}`); }
                    if (stderr !== '') { logMessage(`Err:${stderr}`); }
                    resolve({ stdout, stderr });
                }
            });
        });
    }

    // Check if a directory is a git repository
    private async isGitRepository(dir: string): Promise<boolean> {
        try {
            await this.execCmd(this.gitPath, ['rev-parse', '--is-inside-work-tree'], dir);
            return true;
        } catch (error) {
            return false;
        }
    }
}

function findGitExecutable(): string {
    let gitPath: string;

    // First, search for Git in PATH
    try {
        gitPath = which.sync('git');
        return gitPath;
    } catch (e) {
        // Git not found in PATH
    }

    // Define predefined paths based on platform
    const platform = process.platform;
    let predefinedPaths: string[];

    switch (platform) {
        case 'win32': // Windows
            predefinedPaths = [
                'C:\\Program Files\\Git\\bin\\git.exe',
                'C:\\Git\\bin\\git.exe',
                'C:\\Windows\\System32\\git.exe'
            ];
            break;
        case 'darwin': // macOS
            predefinedPaths = [
                '/usr/local/bin/git',
                '/usr/bin/git'
            ];
            break;
        case 'linux': // Linux
            predefinedPaths = [
                '/usr/local/bin/git',
                '/usr/bin/git',
                '/bin/git'
            ];
            break;
        default:
            throw new Error(`Unsupported platform: ${platform}`);
    }

    // Search predefined paths
    for (const p of predefinedPaths) {
        if (fs.existsSync(p)) {
            gitPath = p;
            return gitPath;
        }
    }

    // If Git is not found, throw an error
    throw new Error('Git executable not found.');
}
### End of src/storage/GithubProvider.ts ###

### Start of src/storage/IStorageProvider.ts ###
// src/IStorageProvider.ts
export interface IStorageProvider {
    /**
     * rsync çš„ãªåŒæ–¹å‘ã®ãƒ•ã‚¡ã‚¤ãƒ«åŒæœŸã‚’è¡Œã†
     *  - ãƒ­ãƒ¼ã‚«ãƒ«ã® .enc ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¯ãƒ©ã‚¦ãƒ‰ã¸
     *  - ã‚¯ãƒ©ã‚¦ãƒ‰ã«ã—ã‹ãªã„ .enc ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã¸
     */
    sync(): Promise<void>;
}

### End of src/storage/IStorageProvider.ts ###

### Start of src/storage/LocalObjectManager.ts ###
// src/LocalObjectManager.ts
import * as vscode from "vscode";
import * as crypto from "crypto";
import { logMessage } from "../logger";
import { IndexFile, FileEntry, Conflict, LocalObjectManagerOptions } from "../types";
import { v7 as uuidv7 } from 'uuid';

const secureNotesDir = ".secureNotes";
const objectDirName = "objects";
const indexDirName = "indexes";
const filesDirName = "files";
const previousIndexIDFilename = "index";
const rootUri = getRootUri();
export const secureNootesUri = vscode.Uri.joinPath(rootUri, secureNotesDir);
export const objectDirUri = vscode.Uri.joinPath(secureNootesUri, objectDirName);
const previousIndexIDUri = vscode.Uri.joinPath(secureNootesUri, previousIndexIDFilename);
const indexDirUri = vscode.Uri.joinPath(objectDirUri, indexDirName);
const filesDirUri = vscode.Uri.joinPath(objectDirUri, filesDirName);

interface FileIndex {
    originalFile: string;
    encryptedFile: string;
}

// ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ãƒ•ã‚©ãƒ«ãƒ€ã‚’å–å¾—
function getRootUri(): vscode.Uri {
    const workspaceUri = vscode.workspace.workspaceFolders ? vscode.workspace.workspaceFolders[0].uri : undefined;
    if (!workspaceUri) {
        throw new Error("No workspace folder found.");
    }
    return workspaceUri;
}

export class LocalObjectManager {
    /**
     * ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹å†…ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æš—å·åŒ–ã—ã€.secureNotes ã«ä¿å­˜
     */
    public static async saveEncryptedObject(
        localFiles: FileEntry[],
        latestIndex: IndexFile,
        options: LocalObjectManagerOptions
    ): Promise<boolean> {
        // ãƒªãƒ¢ãƒ¼ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚·ãƒ¥å€¤ã®ã‚»ãƒƒãƒˆã‚’ä½œæˆ
        const latestFileHashes = new Set(latestIndex.files.map((file) => file.hash));
        let updated = false;
        for (const file of localFiles) {
            // ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒªãƒ¢ãƒ¼ãƒˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
            if (latestFileHashes.has(file.hash)) {
                continue; // æ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆã€ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒƒãƒ—
            }
            // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
            const fileUri = vscode.Uri.joinPath(rootUri, file.path);
            const fileContent = await vscode.workspace.fs.readFile(fileUri);

            // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æš—å·åŒ–
            const encryptedContent = this.encryptContent(Buffer.from(fileContent), options.encryptionKey);

            // objects directory ã«ä¿å­˜
            const { dirName, fileName } = this.getHashPathParts(file.hash);
            const encryptedFileName = vscode.Uri.joinPath(filesDirUri, dirName, fileName);
            await vscode.workspace.fs.writeFile(encryptedFileName, encryptedContent);
            logMessage(`save file:${file.path}, to:${encryptedFileName.path}`);
            updated = true;
        }
        return updated;
    }

    private static getUUIDPathParts(uuid: string): { dirName: string; fileName: string } {
        const dirName = uuid.substring(0, 6);
        const fileName = uuid.substring(6);
        return { dirName, fileName };
    }
    private static getHashPathParts(uuid: string): { dirName: string; fileName: string } {
        const dirName = uuid.substring(0, 2);
        const fileName = uuid.substring(2);
        return { dirName, fileName };
    }

    /**
     * uri ã«ã‚ã‚‹ã™ã¹ã¦ã® fileã®ãƒ‘ã‚¹ä¸€è¦§
     */
    private static async listFiles(uri: vscode.Uri): Promise<string[]> {
        // .secureNotes/indexes ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ç©ºé…åˆ—ã‚’è¿”ã™
        try {
            await vscode.workspace.fs.stat(uri);
        } catch (error) {
            return [];
        }
        const dirs = await vscode.workspace.fs.readDirectory(uri);
        return dirs.filter((f) => f[1] === vscode.FileType.File).map((f) => f[0]);
    }
    /**
     * uri ã«ã‚ã‚‹ã™ã¹ã¦ã®dirã®ãƒ‘ã‚¹ä¸€è¦§
     */
    private static async listDirs(uri: vscode.Uri): Promise<string[]> {
        // .secureNotes/indexes ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ç©ºé…åˆ—ã‚’è¿”ã™
        try {
            await vscode.workspace.fs.stat(uri);
        } catch (error) {
            return [];
        }
        const dirs = await vscode.workspace.fs.readDirectory(uri);
        return dirs.filter((f) => f[1] === vscode.FileType.Directory).map((f) => f[0]);
    }


    public static latestString(strings: string[]): string {
        if (strings.length === 0) { return ""; }
        return strings.reduce((a, b) => (a > b ? a : b));
    }
    /**
     * ãƒ­ãƒ¼ã‚«ãƒ«ã«ã‚ã‚‹ã†ã¡ã€ã‚‚ã£ã¨ã‚‚æ–°ã—ã„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
     */
    public static async loadLatestLocalIndex(options: LocalObjectManagerOptions): Promise<IndexFile> {
        const latestDir = this.latestString(await this.listDirs(indexDirUri));
        const dir = vscode.Uri.joinPath(indexDirUri, latestDir);
        const latestFilePath = this.latestString(await this.listFiles(dir));
        const latestIndexFileUri = vscode.Uri.joinPath(indexDirUri, latestDir, latestFilePath);
        if (latestFilePath.length === 0) {
            // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯æ–°è¦ä½œæˆ
            const uuid = uuidv7();
            logMessage(`Latest index file not found. Creating new index UUID: ${uuid}`);
            return {
                uuid: uuid,
                parentUuid: "",
                environmentId: options.environmentId,
                files: [],
                timestamp: 0,
            };
        }

        const encryptContent = await vscode.workspace.fs.readFile(latestIndexFileUri);
        const content = this.decryptContent(Buffer.from(encryptContent), options.encryptionKey);
        return JSON.parse(content.toString()) as IndexFile;
    }

    // å‰å›ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€é–¢æ•°
    public static async loadPreviousIndex(options: LocalObjectManagerOptions): Promise<IndexFile> {
        try {
            const indexContent = await vscode.workspace.fs.readFile(previousIndexIDUri);
            const uuidparts = this.getUUIDPathParts(indexContent.toString());
            const encryptedIndex = await vscode.workspace.fs.readFile(vscode.Uri.joinPath(indexDirUri, uuidparts.dirName, uuidparts.fileName));
            const index = this.decryptContent(Buffer.from(encryptedIndex), options.encryptionKey);
            return JSON.parse(index.toString());
        } catch (error) {
            // ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã‚„èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯æ–°è¦ä½œæˆ
            const uuid = uuidv7();
            logMessage(`Previous index file not found or error reading file. Creating new index UUID: ${uuid}`);
            return {
                uuid: uuid,
                parentUuid: "",
                environmentId: options.environmentId,
                files: [],
                timestamp: 0,
            };
        }
    }

    /**
     * æ–°ã—ã„ <UUID> ã‚’ä½œæˆã—ä¿å­˜
     */
    public static createNewIndexFile(localIndex: IndexFile, previousIndex: IndexFile): IndexFile {
        const newUUID = uuidv7();
        const newIndexFile: IndexFile = {
            uuid: newUUID,
            parentUuid: previousIndex.uuid,
            environmentId: localIndex.environmentId,
            files: localIndex.files,
            timestamp: Date.now(),
        };

        return newIndexFile;
    }

    /**
     * AES-256-CBC ã§æš—å·åŒ–
     */
    private static encryptContent(content: Buffer, key: string): Buffer {
        const iv = crypto.randomBytes(16);
        const keyBuffer = Buffer.from(key, "hex");
        const cipher = crypto.createCipheriv("aes-256-cbc", keyBuffer, iv);
        const encrypted = Buffer.concat([cipher.update(content), cipher.final()]);
        return Buffer.concat([iv, encrypted]);
    }

    /**
     * AES-256-CBC ã§å¾©å·
     */
    private static decryptContent(encryptedContent: Buffer, key: string): Buffer {
        const iv = encryptedContent.subarray(0, 16);
        const encryptedText = encryptedContent.subarray(16);
        const keyBuffer = Buffer.from(key, "hex");
        const decipher = crypto.createDecipheriv("aes-256-cbc", keyBuffer, iv);
        return Buffer.concat([decipher.update(encryptedText), decipher.final()]);
    }

    // å¾©å·åŒ–ã—ãŸå†…å®¹ã‚’è¿”ã™å…±é€šé–¢æ•°
    private static async decryptFileFromLocalObject(fileHash: string, options: LocalObjectManagerOptions): Promise<Uint8Array> {
        const { dirName, fileName } = this.getHashPathParts(fileHash);
        const filePath = vscode.Uri.joinPath(filesDirUri, dirName, fileName);
        const content = await vscode.workspace.fs.readFile(filePath);
        try {
            return this.decryptContent(Buffer.from(content), options.encryptionKey);
        } catch (error: any) {
            logMessage(`Failed to fetch or decrypt file: ${fileHash}.Error: ${error.message} `);
            throw error;
        }
    }
    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—ã—ã€ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã«ä¿å­˜ã™ã‚‹å…±é€šé–¢æ•°
    private static async fetchDecryptAndSaveFile(
        filePath: string,
        fileHash: string,
        options: LocalObjectManagerOptions,
        conflictFileName?: string,
    ): Promise<void> {
        try {
            const decryptedContent = await this.decryptFileFromLocalObject(fileHash, options);
            const savePath = conflictFileName ? conflictFileName : filePath;

            // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’å–å¾—
            const localUri = vscode.Uri.joinPath(vscode.Uri.file(rootUri.fsPath), savePath);

            // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
            await vscode.workspace.fs.writeFile(localUri, decryptedContent);
            logMessage(`Saved remote file to local path: ${savePath} `);
        } catch (error: any) {
            logMessage(`Failed to save remote file to local path: ${filePath}.Error: ${error.message} `);
            throw error;
        }
    }
    // ãƒªãƒ¢ãƒ¼ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã§ãƒ­ãƒ¼ã‚«ãƒ«ã‚’ä¸Šæ›¸ã
    private static async overwriteLocalFileWithRemote(
        filePath: string,
        fileHash: string,
        options: LocalObjectManagerOptions,
    ): Promise<void> {
        await this.fetchDecryptAndSaveFile(filePath, fileHash, options);
        logMessage(`Overwrote local file with remote content: ${filePath} `);
    }
    // ãƒªãƒ¢ãƒ¼ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ¥åã§ä¿å­˜
    public static async saveRemoteFileAsConflict(
        filePath: string,
        fileHash: string,
        options: LocalObjectManagerOptions
    ): Promise<void> {
        // ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆç”¨ã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆï¼ˆä¾‹: conflict-YYYYMMDD-HHmmss-ãƒ•ã‚¡ã‚¤ãƒ«å.extï¼‰
        const timestamp = new Date().toISOString().replace(/[:.]/g, "-").replace("T", "_").split("Z")[0];
        const conflictFileName = `conflict - ${timestamp} -${filePath} `;
        await this.fetchDecryptAndSaveFile(filePath, fileHash, options, conflictFileName);
        logMessage(`Saved remote file as conflict file: ${conflictFileName} `);
    }

    // æ¤œå‡ºã•ã‚ŒãŸç«¶åˆã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€šçŸ¥ã—ã€è§£æ±ºã—ã¾ã™ã€‚
    public static async resolveConflicts(
        conflicts: Conflict[],
        options: LocalObjectManagerOptions
    ): Promise<boolean> {
        for (const conflict of conflicts) {
            if (conflict.localHash.length === 0) {
                logMessage(`Remote only file: ${conflict.filePath} `);
                await this.fetchDecryptAndSaveFile(conflict.filePath, conflict.remoteHash, options);
                continue;
            }
            const choice = await vscode.window.showQuickPick(
                ["Keep Local Version", "Keep Remote Version", "Save Remote as Conflict File", "Abort Sync"],
                {
                    placeHolder: `Conflict detected in file: ${conflict.filePath} `,
                }
            );

            if (choice === "Keep Local Version") {
                // ãƒ­ãƒ¼ã‚«ãƒ«ã®å¤‰æ›´ã‚’é©ç”¨ï¼ˆä½•ã‚‚ã—ãªã„ï¼‰
                continue;
            } else if (choice === "Keep Remote Version") {
                // ãƒªãƒ¢ãƒ¼ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã§ãƒ­ãƒ¼ã‚«ãƒ«ã‚’ä¸Šæ›¸ã
                await this.overwriteLocalFileWithRemote(conflict.filePath, conflict.remoteHash, options);
            } else if (choice === "Save Remote as Conflict File") {
                // ãƒªãƒ¢ãƒ¼ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ¥åã§ä¿å­˜
                await this.saveRemoteFileAsConflict(conflict.filePath, conflict.remoteHash, options);
            } else if (choice === "Abort Sync" || !choice) {
                // åŒæœŸã‚’ä¸­æ­¢
                return false;
            }
        }
        return true;
    }
    // ãƒ­ãƒ¼ã‚«ãƒ«ã¨ãƒªãƒ¢ãƒ¼ãƒˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¯”è¼ƒã—ã€ç«¶åˆã‚’æ¤œå‡ºã—ã¾ã™ã€‚
    public static detectConflicts(localIndex: IndexFile, remoteIndex: IndexFile): Conflict[] {
        const conflicts: Conflict[] = [];

        // ãƒªãƒ¢ãƒ¼ãƒˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ UUID ã¨ãƒ­ãƒ¼ã‚«ãƒ«ã® parentUuid ã‚’æ¯”è¼ƒ
        if (remoteIndex.uuid === localIndex.parentUuid) {
            // ãƒªãƒ¢ãƒ¼ãƒˆã«å¤‰æ›´ãŒãªã„ãŸã‚ã€ç«¶åˆãªã—
            return conflicts;
        }

        // ãƒªãƒ¢ãƒ¼ãƒˆã«å¤‰æ›´ãŒã‚ã‚‹å ´åˆã®ã¿ç«¶åˆã‚’æ¤œå‡º
        const remoteFileMap = new Map<string, FileEntry>();
        for (const file of remoteIndex.files) {
            remoteFileMap.set(file.path, file);
        }

        for (const localFile of localIndex.files) {
            const remoteFile = remoteFileMap.get(localFile.path);
            if (remoteFile) {
                if (localFile.hash !== remoteFile.hash) {
                    // ãƒãƒƒã‚·ãƒ¥å€¤ãŒç•°ãªã‚‹å ´åˆã€ç«¶åˆã¨åˆ¤æ–­
                    conflicts.push({
                        filePath: localFile.path,
                        localHash: localFile.hash,
                        remoteHash: remoteFile.hash,
                        localTimestamp: localFile.timestamp,
                        remoteTimestamp: remoteFile.timestamp,
                    });
                }
                // æ¯”è¼ƒå¾Œã«å‰Šé™¤
                remoteFileMap.delete(localFile.path);
            }
        }

        // ãƒ­ãƒ¼ã‚«ãƒ«ã«å­˜åœ¨ã›ãšã€ãƒªãƒ¢ãƒ¼ãƒˆã«å­˜åœ¨ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚‚è€ƒæ…®
        for (const remoteFile of remoteFileMap.values()) {
            conflicts.push({
                filePath: remoteFile.path,
                localHash: "",
                remoteHash: remoteFile.hash,
                localTimestamp: 0,
                remoteTimestamp: remoteFile.timestamp,
            });
        }

        return conflicts;
    }
    // ãƒ­ãƒ¼ã‚«ãƒ«ã®ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã€ãƒãƒƒã‚·ãƒ¥å€¤ã€ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å–å¾—ã—ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
    static async generateLocalIndexFile(previousIndex: IndexFile, options: LocalObjectManagerOptions): Promise<IndexFile> {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            throw new Error("No workspace folders found.");
        }

        const files: FileEntry[] = [];
        const previousFileMap = new Map<string, FileEntry>();
        if (previousIndex) {
            // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’ã‚­ãƒ¼ã«ã—ã¦ãƒãƒƒãƒ—ã«ä¿å­˜
            for (const file of previousIndex.files) {
                previousFileMap.set(file.path, file);
            }
        }

        for (const folder of workspaceFolders) {
            const filesInFolder = await vscode.workspace.findFiles(
                new vscode.RelativePattern(folder, "**/*"),
                `{**/node_modules/**,${secureNotesDir}/**}`
            );

            for (const fileUri of filesInFolder) {
                const stat = await vscode.workspace.fs.stat(fileUri);
                const relativePath = vscode.workspace.asRelativePath(fileUri, false);

                // å‰å›ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«åŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹ã‹ç¢ºèª
                const previousFileEntry = previousFileMap.get(relativePath);

                if (previousFileEntry && previousFileEntry.timestamp === stat.mtime) {
                    // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãŒåŒã˜å ´åˆã€ãƒãƒƒã‚·ãƒ¥å€¤ã‚’å†åˆ©ç”¨
                    files.push({
                        path: relativePath,
                        hash: previousFileEntry.hash,
                        timestamp: stat.mtime,
                    });
                } else {
                    // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãŒç•°ãªã‚‹å ´åˆã€ãƒãƒƒã‚·ãƒ¥å€¤ã‚’å†è¨ˆç®—
                    const fileContent = await vscode.workspace.fs.readFile(fileUri);
                    const hash = crypto.createHash("sha256").update(fileContent).digest("hex");

                    files.push({
                        path: relativePath,
                        hash: hash,
                        timestamp: stat.mtime,
                    });
                }
            }
        }

        const indexFile: IndexFile = {
            uuid: uuidv7(),
            parentUuid: previousIndex.uuid, // ã“ã“ã§ãƒªãƒ¢ãƒ¼ãƒˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ UUID ã‚’è¨­å®š
            environmentId: options.environmentId,
            files: files,
            timestamp: Date.now(),
        };


        return indexFile;
    }
    // æ–°ã—ã„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã«ä¿å­˜ã™ã‚‹é–¢æ•°
    public static async saveLocalIndexFile(indexFile: IndexFile, options: LocalObjectManagerOptions): Promise<void> {
        const { dirName, fileName } = this.getUUIDPathParts(indexFile.uuid);
        const dirPath = vscode.Uri.joinPath(indexDirUri, dirName);
        await vscode.workspace.fs.createDirectory(dirPath);
        const indexContent = Buffer.from(JSON.stringify(indexFile, null, 2), "utf-8");
        const indexFileName = indexFile.uuid;
        const indexFilePath = vscode.Uri.joinPath(indexDirUri, dirName, fileName);
        const encryptedIndex = this.encryptContent(indexContent, options.encryptionKey);
        await vscode.workspace.fs.writeFile(indexFilePath, encryptedIndex);
        await vscode.workspace.fs.writeFile(previousIndexIDUri, Buffer.from(indexFileName));
    }
}

### End of src/storage/LocalObjectManager.ts ###

