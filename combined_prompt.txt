‰ª•‰∏ã„ÅÆ„Ç≥„Éº„Éâ„ÅØvscodeÊã°Âºµ„ÅÆ„Ç≥„Éº„Éâ„Åß„Åô„ÄÇ
„Åì„ÅÆÊã°Âºµ„ÅØvscode„ÉØ„Éº„ÇØ„Çπ„Éö„Éº„Çπ„Å´„ÅÇ„Çã„Éï„Ç°„Ç§„É´„ÇíÊöóÂè∑Âåñ„Åóindex„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê„Åó„Å¶„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å£„Éá„Ç£„É¨„ÇØ„Éà„É™„Å´‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇ
„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Éá„Ç£„É¨„ÇØ„Éà„É™„Çígit„Ç≥„Éû„É≥„Éâ„Åßgithub„ÅÆ„É™„Éù„Ç∏„Éà„É™„Å´ÂêåÊúü„Åô„ÇãÊ©üËÉΩ„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

### Start of webpack.config.js ###
//@ts-check

'use strict';

const path = require('path');

//@ts-check
/** @typedef {import('webpack').Configuration} WebpackConfig **/

/** @type WebpackConfig */
const extensionConfig = {
  target: 'node', // VS Code extensions run in a Node.js-context üìñ -> https://webpack.js.org/configuration/node/
	mode: 'none', // this leaves the source code as close as possible to the original (when packaging we set this to 'production')

  entry: './src/extension.ts', // the entry point of this extension, üìñ -> https://webpack.js.org/configuration/entry-context/
  output: {
    // the bundle is stored in the 'dist' folder (check package.json), üìñ -> https://webpack.js.org/configuration/output/
    path: path.resolve(__dirname, 'dist'),
    filename: 'extension.js',
    libraryTarget: 'commonjs2'
  },
  externals: {
    vscode: 'commonjs vscode' // the vscode-module is created on-the-fly and must be excluded. Add other modules that cannot be webpack'ed, üìñ -> https://webpack.js.org/configuration/externals/
    // modules added here also need to be added in the .vscodeignore file
  },
  resolve: {
    // support reading TypeScript and JavaScript files, üìñ -> https://github.com/TypeStrong/ts-loader
    extensions: ['.ts', '.js']
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        exclude: /node_modules/,
        use: [
          {
            loader: 'ts-loader'
          }
        ]
      }
    ]
  },
  devtool: 'nosources-source-map',
  infrastructureLogging: {
    level: "log", // enables logging required for problem matchers
  },
};
module.exports = [ extensionConfig ];
### End of webpack.config.js ###

### Start of src/envUtils.ts ###
// src/envUtils.ts
import * as vscode from "vscode";
import * as os from "os";
import * as crypto from "crypto";

const ENV_ID_KEY = "encryptSyncEnvironmentId";

export async function getOrCreateEnvironmentId(context: vscode.ExtensionContext): Promise<string> {
    let envId = context.globalState.get<string>(ENV_ID_KEY);
    if (!envId) {
        const hostname = os.hostname();
        envId = `${hostname}-${crypto.randomUUID()}`;
        await context.globalState.update(ENV_ID_KEY, envId);
    }
    return envId;
}

### End of src/envUtils.ts ###

### Start of src/extension.ts ###
// VSCode Extension Skeleton for Note-Taking App with S3 Integration
import * as vscode from "vscode";
import { logMessage, showInfo, showError, setOutputChannel } from "./logger";
import { setSecret } from "./secretManager";
import { LocalObjectManager } from "./storage/LocalObjectManager";
import { getOrCreateEnvironmentId } from "./envUtils";
import * as crypto from "crypto";


const aesEncryptionKey = "aesEncryptionKey";
const appName = "SecureNotesSync";

export async function activate(context: vscode.ExtensionContext) {
  // Create output channel
  const outputChannel = vscode.window.createOutputChannel(appName);
  setOutputChannel(outputChannel);
  showInfo(`${appName} Extension Activated`);

  // Áí∞Â¢ÉID„ÇíÁîüÊàêorÂèñÂæó („Éõ„Çπ„ÉàÂêç + UUID)
  const environmentId = await getOrCreateEnvironmentId(context);
  logMessage(`Current Environment ID: ${environmentId}`);

  // Command to Set AES Key
  let setAESKeyCommand = vscode.commands.registerCommand("extension.setAESKey", () =>
    setSecret(context,
      aesEncryptionKey,
      "Enter AES Encryption Key (64 hex characters representing 32 bytes)",
      true,
      (value) => value.length === 64 ? null : "AES Key must be 64 hex characters long"
    )
  );

  // Command to Set AWS Credentials
  let setAWSSecretCommand = vscode.commands.registerCommand("extension.setAWSSecretCommand", async () => {
    const awsAccessKeyId = await vscode.window.showInputBox({
      prompt: "Enter AWS Access Key ID",
    });
    const awsSecretAccessKey = await vscode.window.showInputBox({
      prompt: "Enter AWS Secret Access Key",
      password: true,
    });

    if (awsAccessKeyId && awsSecretAccessKey) {
      const config = vscode.workspace.getConfiguration(appName);
      await config.update("awsAccessKeyId", awsAccessKeyId, vscode.ConfigurationTarget.Global);
      await context.secrets.store("awsSecretAccessKey", awsSecretAccessKey);
      showInfo("AWS Credentials saved successfully.");
    } else {
      showError("Both AWS Access Key ID and Secret Access Key are required.");
    }
  });

  // Command to Generate 32-Byte Encrypted Text
  let generateAESKeyCommand = vscode.commands.registerCommand("extension.generateAESKey", async () => {
    logMessage("Generating 32-byte AES encryption key...");
    const key = crypto.randomBytes(32).toString("hex"); // 32 bytes
    try {
      await context.secrets.store("aesEncryptionKey", key);
      showInfo(`Generated and stored AES key: ${key}`);
    } catch (error: any) {
      showError(`Error generating encrypted text: ${error instanceof Error ? error.message : String(error)}`);
    }
  });

  let syncCommand = vscode.commands.registerCommand("extension.syncNotes", async () => {
    try {
      // 1. S3„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÊ∫ñÂÇô
      const encryptKey = await context.secrets.get(aesEncryptionKey);
      if (!encryptKey) {
        showError("AES Key not set");
        return false;
      }
      const config = vscode.workspace.getConfiguration("encryptSync");
      const options = { environmentId, encryptionKey: encryptKey };
      // const awsAccessKeyId = config.get<string>("awsAccessKeyId");
      // const awsSecretAccessKey = await context.secrets.get("awsSecretAccessKey");
      // const s3Bucket = config.get<string>("s3Bucket");
      // const s3Region = config.get<string>("s3Region");
      // if (!awsAccessKeyId || !awsSecretAccessKey || !s3Bucket || !s3Region) {
      //   showError("S3 config incomplete");
      //   return;
      // }

      // TODO: 2. S3 „Å®„É≠„Éº„Ç´„É´„ÇíÂêåÊúü„Åô„Çã
      // const s3Client = new S3Client({ region: s3Region, credentials: { accessKeyId: awsAccessKeyId, secretAccessKey: awsSecretAccessKey } });
      // const provider: IStorageProvider = new S3StorageProvider(s3Client, s3Bucket, "files");
      // await provider.sync();
      // showInfo("Rsync-like sync completed.");

      // 3. „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Éï„Ç°„Ç§„É´„ÇíÊõ¥Êñ∞„Åó„Åü„ÅÑÂ†¥Âêà (‰æã):
      //    ‰æã„Å®„Åó„Å¶„Äå„É≠„Éº„Ç´„É´„Å´„ÅÇ„ÇãÊúÄÊñ∞Index„Å´Â§âÊõ¥„Åå„ÅÇ„Çå„Å∞„ÄÅÊñ∞„Åó„ÅÑindex-xxx.json„Çí‰Ωú„Çã„Äç
      const latestIndex = await LocalObjectManager.loadLatestLocalIndex(options);
      const previousIndex = await LocalObjectManager.loadPreviousIndex(options);
      const localIndex = await LocalObjectManager.generateLocalIndexFile(previousIndex, options);
      const conflicts = LocalObjectManager.detectConflicts(localIndex, latestIndex);
      if (conflicts.length > 0) {
        const conflictsResolved = await LocalObjectManager.resolveConflicts(conflicts, options);
        if (!conflictsResolved) {
          showInfo("Sync aborted due to unresolved conflicts.");
          return true;
        }
      }

      // 7. Êñ∞Ë¶è„Åæ„Åü„ÅØÂ§âÊõ¥„Åï„Çå„Åü„Éï„Ç°„Ç§„É´„Çí S3 „Å´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
      const updated = await LocalObjectManager.saveEncryptedObject(localIndex.files, latestIndex, options);

      if (!updated) {
        showInfo("There are no update files.");
        return;
      }

      // 8. „É≠„Éº„Ç´„É´„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Éï„Ç°„Ç§„É´„ÇíÊõ¥Êñ∞
      const newIndex = LocalObjectManager.createNewIndexFile(localIndex, previousIndex);
      showInfo("New local index file created.");
      LocalObjectManager.saveLocalIndexFile(newIndex);
    } catch (error: any) {
      showError(`Sync failed: ${error.message}`);
    }
    return true;
  });

  context.subscriptions.push(syncCommand, setAESKeyCommand, generateAESKeyCommand);
  outputChannel.show(true);
}

export function deactivate() {
  logMessage(`${appName} Extension Deactivated.`);
}
### End of src/extension.ts ###

### Start of src/logger.ts ###
import * as vscode from "vscode";

let outputChannel: vscode.OutputChannel;

export function setOutputChannel(channel: vscode.OutputChannel) {
  outputChannel = channel;
}

// Log message to output channel
export function logMessage(message: string) {
  outputChannel.appendLine(message);
}

// Show error message and log
export function showError(message: string) {
  vscode.window.showErrorMessage(message);
  logMessage(message);
}

// Show info message and log
export function showInfo(message: string) {
  vscode.window.showInformationMessage(message);
  logMessage(message);
}

### End of src/logger.ts ###

### Start of src/secretManager.ts ###
import * as vscode from "vscode";
import { showInfo, showError } from "./logger";

// Command to set secrets (AES Key or AWS Secret Access Key)
export async function setSecret(
  context: vscode.ExtensionContext,
  secretName: string,
  prompt: string,
  password: boolean = false,
  validate?: (value: string) => string | null
) {
  const secretValue = await vscode.window.showInputBox({
    prompt,
    password,
    validateInput: validate,
  });

  if (secretValue) {
    await context.secrets.store(secretName, secretValue);
    showInfo(`${secretName} saved successfully.`);
  } else {
    showError(`${secretName} is required.`);
  }
}

export async function getSecret(
  context: vscode.ExtensionContext,
  secretName: string
): Promise<string> {
  const aesEncryptionKey = (await context.secrets.get("aesEncryptionKey"))!;
  if (!aesEncryptionKey) {
    throw new Error("AES key not set. Please set the AES key first.");
  }
  return aesEncryptionKey;
}
### End of src/secretManager.ts ###

### Start of src/types.ts ###
// „Éï„Ç°„Ç§„É´ÊÉÖÂ†±„Çí‰øùÊåÅ„Åô„Çã„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ
export interface FileEntry {
    path: string; // „Éï„Ç°„Ç§„É´„ÅÆÁõ∏ÂØæ„Éë„Çπ
    hash: string; // „Éï„Ç°„Ç§„É´„ÅÆSHA-256„Éè„ÉÉ„Ç∑„É•ÂÄ§ÔºàÊöóÂè∑ÂåñÂâç„ÅÆ„Éá„Éº„Çø„Å´ÂØæ„Åó„Å¶Ë®àÁÆóÔºâ
    timestamp: number; // „Éï„Ç°„Ç§„É´„ÅÆÊúÄÁµÇÊõ¥Êñ∞„Çø„Ç§„É†„Çπ„Çø„É≥„Éó
}

// „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Éï„Ç°„Ç§„É´„ÅÆÊßãÈÄ†
export interface IndexFile {
    uuid: string; // „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Éï„Ç°„Ç§„É´„ÅÆUUIDÔºàVersion 7Ôºâ
    environmentId: string; // ËøΩÂä†
    parentUuid: string; // Ë¶™„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Éï„Ç°„Ç§„É´„ÅÆUUID
    files: FileEntry[]; // „Éï„Ç°„Ç§„É´ÊÉÖÂ†±„ÅÆ„É™„Çπ„Éà
    timestamp: number; // „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Éï„Ç°„Ç§„É´„ÅÆ‰ΩúÊàê„Çø„Ç§„É†„Çπ„Çø„É≥„Éó
}

// Á´∂ÂêàÊÉÖÂ†±„Çí‰øùÊåÅ„Åô„Çã„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ
export interface Conflict {
    filePath: string; // Á´∂Âêà„Åó„Å¶„ÅÑ„Çã„Éï„Ç°„Ç§„É´„ÅÆ„Éë„Çπ
    localHash: string; // „É≠„Éº„Ç´„É´„Éï„Ç°„Ç§„É´„ÅÆ„Éè„ÉÉ„Ç∑„É•ÂÄ§
    remoteHash: string; // „É™„É¢„Éº„Éà„Éï„Ç°„Ç§„É´„ÅÆ„Éè„ÉÉ„Ç∑„É•ÂÄ§
    localTimestamp: number; // „É≠„Éº„Ç´„É´„Éï„Ç°„Ç§„É´„ÅÆ„Çø„Ç§„É†„Çπ„Çø„É≥„Éó
    remoteTimestamp: number; // „É™„É¢„Éº„Éà„Éï„Ç°„Ç§„É´„ÅÆ„Çø„Ç§„É†„Çπ„Çø„É≥„Éó
}
export type LocalObjectManagerOptions = {
    environmentId: string;
    encryptionKey: string;
};
### End of src/types.ts ###

### Start of src/storage/IStorageProvider.ts ###
// src/IStorageProvider.ts
export interface IStorageProvider {
    /**
     * rsync ÁöÑ„Å™ÂèåÊñπÂêë„ÅÆ„Éï„Ç°„Ç§„É´ÂêåÊúü„ÇíË°å„ÅÜ
     *  - „É≠„Éº„Ç´„É´„ÅÆ .enc „Éï„Ç°„Ç§„É´„Çí„ÇØ„É©„Ç¶„Éâ„Å∏
     *  - „ÇØ„É©„Ç¶„Éâ„Å´„Åó„Åã„Å™„ÅÑ .enc „Éï„Ç°„Ç§„É´„Çí„É≠„Éº„Ç´„É´„Å∏
     */
    sync(): Promise<void>;
}

### End of src/storage/IStorageProvider.ts ###

### Start of src/storage/LocalObjectManager.ts ###
// src/LocalObjectManager.ts
import * as vscode from "vscode";
import * as crypto from "crypto";
import { logMessage } from "../logger";
import { IndexFile, FileEntry, Conflict, LocalObjectManagerOptions } from "../types";
import { v7 as uuidv7 } from 'uuid';

const secureNotesDir = ".secureNotes";
const indexDirName = "indexes";
const filesDirName = "files";
const previousIndexIDFilename = "index";
const rootUri = getRootUri();
const secureNootesUri = vscode.Uri.joinPath(rootUri, secureNotesDir);
const indexDirUri = vscode.Uri.joinPath(secureNootesUri, indexDirName);
const filesDirUri = vscode.Uri.joinPath(secureNootesUri, filesDirName);
const previousIndexIDUri = vscode.Uri.joinPath(secureNootesUri, previousIndexIDFilename);

interface FileIndex {
    originalFile: string;
    encryptedFile: string;
}

// „ÉØ„Éº„ÇØ„Çπ„Éö„Éº„Çπ„Éï„Ç©„É´„ÉÄ„ÇíÂèñÂæó
function getRootUri(): vscode.Uri {
    const workspaceUri = vscode.workspace.workspaceFolders ? vscode.workspace.workspaceFolders[0].uri : undefined;
    if (!workspaceUri) {
        throw new Error("No workspace folder found.");
    }
    return workspaceUri;
}

export class LocalObjectManager {
    /**
     * „ÉØ„Éº„ÇØ„Çπ„Éö„Éº„ÇπÂÜÖ„Éï„Ç°„Ç§„É´„ÇíÊöóÂè∑Âåñ„Åó„ÄÅ.secureNotes „Å´‰øùÂ≠ò
     */
    public static async saveEncryptedObject(
        localFiles: FileEntry[],
        latestIndex: IndexFile,
        options: LocalObjectManagerOptions
    ): Promise<boolean> {
        // „É™„É¢„Éº„Éà„ÅÆ„Éï„Ç°„Ç§„É´„Éè„ÉÉ„Ç∑„É•ÂÄ§„ÅÆ„Çª„ÉÉ„Éà„Çí‰ΩúÊàê
        const latestFileHashes = new Set(latestIndex.files.map((file) => file.hash));
        let updated = false;
        for (const file of localFiles) {
            // „Éï„Ç°„Ç§„É´„Åå„É™„É¢„Éº„Éà„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Å´Â≠òÂú®„Åô„Çã„ÅãÁ¢∫Ë™ç
            if (latestFileHashes.has(file.hash)) {
                continue; // Êó¢„Å´Â≠òÂú®„Åô„ÇãÂ†¥Âêà„ÄÅ„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Çí„Çπ„Ç≠„ÉÉ„Éó
            }
            // „Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Åø
            const fileUri = vscode.Uri.joinPath(rootUri, file.path);
            const fileContent = await vscode.workspace.fs.readFile(fileUri);

            // „Éï„Ç°„Ç§„É´„ÇíÊöóÂè∑Âåñ
            const encryptedContent = this.encryptContent(Buffer.from(fileContent), options.encryptionKey);

            // objects directory „Å´‰øùÂ≠ò
            const encryptedFileName = vscode.Uri.joinPath(filesDirUri, file.hash);
            await vscode.workspace.fs.writeFile(encryptedFileName, encryptedContent);
            logMessage(`save file:${file.path}, to:${encryptedFileName.path}`);
            updated = true;
        }
        return updated;
    }

    /**
     * „É≠„Éº„Ç´„É´ .secureNotes/indexes „Å´„ÅÇ„Çã„Åô„Åπ„Å¶„ÅÆ index-<UUID>.json „ÅÆ„Éë„Çπ‰∏ÄË¶ß
     */
    public static async listLocalIndexFiles(): Promise<string[]> {
        // .secureNotes/indexes „Éá„Ç£„É¨„ÇØ„Éà„É™„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØÁ©∫ÈÖçÂàó„ÇíËøî„Åô
        try {
            await vscode.workspace.fs.stat(indexDirUri);
        } catch (error) {
            return [];
        }
        const dirs = await vscode.workspace.fs.readDirectory(indexDirUri);
        return dirs.filter(
            (f) => f[1] === vscode.FileType.File
                && f[0].startsWith("index-")
                && f[0].endsWith(".json")
        ).map((f) => f[0]);
    }

    /**
     * „É≠„Éº„Ç´„É´„Å´„ÅÇ„Çã„ÅÜ„Å°„ÄÅ„ÇÇ„Å£„Å®„ÇÇÊñ∞„Åó„ÅÑ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„ÇÄ
     */
    public static async loadLatestLocalIndex(options: LocalObjectManagerOptions): Promise<IndexFile> {
        const indexFiles = await this.listLocalIndexFiles();
        if (indexFiles.length === 0) {
            // „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Éï„Ç°„Ç§„É´„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØÊñ∞Ë¶è‰ΩúÊàê
            return {
                uuid: uuidv7(),
                parentUuid: "",
                environmentId: options.environmentId,
                files: [],
                timestamp: 0,
            };
        }

        // 1) „Éï„Ç°„Ç§„É´ÂêçÔºàbasenameÔºâ„ÇíÊäΩÂá∫„Åó„Å¶„ÇΩ„Éº„ÉàÔºàÈôçÈ†ÜÔºâ
        //    "index-017f8d3f-e23c-7aa6-85f8-fc1855b36328.json" „ÅÆÊØîËºÉ„Åß„ÄÅ
        //    UUIDv7ÈÉ®ÂàÜ„ÇíÂê´„ÇÄÊñáÂ≠óÂàó„ÇíÊØîËºÉ„Åô„Çã
        indexFiles.sort((a, b) => {
            // ÈôçÈ†Ü„Å™„ÅÆ„ÅßB‚ÜíA„ÅÆÈ†Ü„ÅßËøî„Åô
            if (a < b) { return 1; }
            if (a > b) { return -1; }
            return 0;
        });

        // 2) ÂÖàÈ†≠(ÊúÄ„ÇÇÊñ∞„Åó„ÅÑ=‰∏ÄÁï™Â§ß„Åç„ÅÑUUIDv7)„ÇíË™≠„ÅøËæº„ÇÄ
        const latestFilePath = indexFiles[0];
        const latestIndexFileUri = vscode.Uri.joinPath(indexDirUri, latestFilePath);
        const content = await vscode.workspace.fs.readFile(latestIndexFileUri);
        return JSON.parse(content.toString()) as IndexFile;
    }

    // ÂâçÂõû„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„ÇÄÈñ¢Êï∞
    public static async loadPreviousIndex(options: LocalObjectManagerOptions): Promise<IndexFile> {
        try {
            const indexContent = await vscode.workspace.fs.readFile(previousIndexIDUri);
            const index = await vscode.workspace.fs.readFile(vscode.Uri.joinPath(indexDirUri, indexContent.toString()));
            return JSON.parse(index.toString());
        } catch (error) {
            // „Éï„Ç°„Ç§„É´„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÇÑË™≠„ÅøËæº„Åø„Ç®„É©„Éº„ÅÆÂ†¥Âêà„ÅØÊñ∞Ë¶è‰ΩúÊàê
            return {
                uuid: uuidv7(),
                parentUuid: "",
                environmentId: options.environmentId,
                files: [],
                timestamp: 0,
            };
        }
    }

    /**
     * Êñ∞„Åó„ÅÑ index-<UUID>.json „Çí‰ΩúÊàê„Åó‰øùÂ≠ò
     */
    public static createNewIndexFile(localIndex: IndexFile, previousIndex: IndexFile): IndexFile {
        const newUUID = uuidv7();
        const newIndexFile: IndexFile = {
            uuid: newUUID,
            parentUuid: previousIndex.uuid,
            environmentId: localIndex.environmentId,
            files: localIndex.files,
            timestamp: Date.now(),
        };

        return newIndexFile;
    }
    /*
        vscode.workspace.fs.createDirectory(filesDirUri);
        const fileUri = vscode.Uri.joinPath(indexDirUri, `index-${newUUID}.json`);
        const encryptedIndex = this.encryptContent(Buffer.from(JSON.stringify(newIndex, null, 2)), options.encryptionKey);
        vscode.workspace.fs.writeFile(fileUri, encryptedIndex);
        */



    /**
     * AES-256-CBC „ÅßÊöóÂè∑Âåñ
     */
    private static encryptContent(content: Buffer, key: string): Buffer {
        const iv = crypto.randomBytes(16);
        const keyBuffer = Buffer.from(key, "hex");
        const cipher = crypto.createCipheriv("aes-256-cbc", keyBuffer, iv);
        const encrypted = Buffer.concat([cipher.update(content), cipher.final()]);
        return Buffer.concat([iv, encrypted]);
    }

    /**
     * AES-256-CBC „ÅßÂæ©Âè∑
     */
    private static decryptContent(encryptedContent: Buffer, key: string): Buffer {
        const iv = encryptedContent.subarray(0, 16);
        const encryptedText = encryptedContent.subarray(16);
        const keyBuffer = Buffer.from(key, "hex");
        const decipher = crypto.createDecipheriv("aes-256-cbc", keyBuffer, iv);
        return Buffer.concat([decipher.update(encryptedText), decipher.final()]);
    }

    // Âæ©Âè∑Âåñ„Åó„ÅüÂÜÖÂÆπ„ÇíËøî„ÅôÂÖ±ÈÄöÈñ¢Êï∞
    private static async decryptFileFromLocalObject(fileHash: string, options: LocalObjectManagerOptions): Promise<Uint8Array> {
        const filePath = vscode.Uri.joinPath(filesDirUri, fileHash);
        const content = await vscode.workspace.fs.readFile(filePath);
        try {
            return this.decryptContent(Buffer.from(content), options.encryptionKey);
        } catch (error: any) {
            logMessage(`Failed to fetch or decrypt file: ${fileHash}.Error: ${error.message} `);
            throw error;
        }
    }
    // „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Éá„Ç£„É¨„ÇØ„Éà„É™„Åã„Çâ„Éï„Ç°„Ç§„É´„ÇíÂèñÂæó„Åó„ÄÅ„ÉØ„Éº„ÇØ„Çπ„Éö„Éº„Çπ„Å´‰øùÂ≠ò„Åô„ÇãÂÖ±ÈÄöÈñ¢Êï∞
    private static async fetchDecryptAndSaveFile(
        filePath: string,
        fileHash: string,
        options: LocalObjectManagerOptions,
        conflictFileName?: string,
    ): Promise<void> {
        try {
            const decryptedContent = await this.decryptFileFromLocalObject(fileHash, options);
            const savePath = conflictFileName ? conflictFileName : filePath;

            // „É≠„Éº„Ç´„É´„Éï„Ç°„Ç§„É´„Éë„Çπ„ÇíÂèñÂæó
            const localUri = vscode.Uri.joinPath(vscode.Uri.file(rootUri.fsPath), savePath);

            // „É≠„Éº„Ç´„É´„Éï„Ç°„Ç§„É´„Å´‰øùÂ≠ò
            await vscode.workspace.fs.writeFile(localUri, decryptedContent);
            logMessage(`Saved remote file to local path: ${savePath} `);
        } catch (error: any) {
            logMessage(`Failed to save remote file to local path: ${filePath}.Error: ${error.message} `);
            throw error;
        }
    }
    // „É™„É¢„Éº„Éà„ÅÆ„Éï„Ç°„Ç§„É´„Åß„É≠„Éº„Ç´„É´„Çí‰∏äÊõ∏„Åç
    private static async overwriteLocalFileWithRemote(
        filePath: string,
        fileHash: string,
        options: LocalObjectManagerOptions,
    ): Promise<void> {
        await this.fetchDecryptAndSaveFile(filePath, fileHash, options);
        logMessage(`Overwrote local file with remote content: ${filePath} `);
    }
    // „É™„É¢„Éº„Éà„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÂà•Âêç„Åß‰øùÂ≠ò
    public static async saveRemoteFileAsConflict(
        filePath: string,
        fileHash: string,
        options: LocalObjectManagerOptions
    ): Promise<void> {
        // „Ç≥„É≥„Éï„É™„ÇØ„ÉàÁî®„ÅÆ„Éï„Ç°„Ç§„É´Âêç„ÇíÁîüÊàêÔºà‰æã: conflict-YYYYMMDD-HHmmss-„Éï„Ç°„Ç§„É´Âêç.extÔºâ
        const timestamp = new Date().toISOString().replace(/[:.]/g, "-").replace("T", "_").split("Z")[0];
        const conflictFileName = `conflict - ${timestamp} -${filePath} `;
        await this.fetchDecryptAndSaveFile(filePath, fileHash, options, conflictFileName);
        logMessage(`Saved remote file as conflict file: ${conflictFileName} `);
    }

    // Ê§úÂá∫„Åï„Çå„ÅüÁ´∂Âêà„Çí„É¶„Éº„Ç∂„Éº„Å´ÈÄöÁü•„Åó„ÄÅËß£Ê±∫„Åó„Åæ„Åô„ÄÇ
    public static async resolveConflicts(
        conflicts: Conflict[],
        options: LocalObjectManagerOptions
    ): Promise<boolean> {
        for (const conflict of conflicts) {
            if (conflict.localHash.length === 0) {
                logMessage(`Remote only file: ${conflict.filePath} `);
                await this.fetchDecryptAndSaveFile(conflict.filePath, conflict.remoteHash, options);
                continue;
            }
            const choice = await vscode.window.showQuickPick(
                ["Keep Local Version", "Keep Remote Version", "Save Remote as Conflict File", "Abort Sync"],
                {
                    placeHolder: `Conflict detected in file: ${conflict.filePath} `,
                }
            );

            if (choice === "Keep Local Version") {
                // „É≠„Éº„Ç´„É´„ÅÆÂ§âÊõ¥„ÇíÈÅ©Áî®Ôºà‰Ωï„ÇÇ„Åó„Å™„ÅÑÔºâ
                continue;
            } else if (choice === "Keep Remote Version") {
                // „É™„É¢„Éº„Éà„ÅÆ„Éï„Ç°„Ç§„É´„Åß„É≠„Éº„Ç´„É´„Çí‰∏äÊõ∏„Åç
                await this.overwriteLocalFileWithRemote(conflict.filePath, conflict.remoteHash, options);
            } else if (choice === "Save Remote as Conflict File") {
                // „É™„É¢„Éº„Éà„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÂà•Âêç„Åß‰øùÂ≠ò
                await this.saveRemoteFileAsConflict(conflict.filePath, conflict.remoteHash, options);
            } else if (choice === "Abort Sync" || !choice) {
                // ÂêåÊúü„Çí‰∏≠Ê≠¢
                return false;
            }
        }
        return true;
    }
    // „É≠„Éº„Ç´„É´„Å®„É™„É¢„Éº„Éà„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Éï„Ç°„Ç§„É´„ÇíÊØîËºÉ„Åó„ÄÅÁ´∂Âêà„ÇíÊ§úÂá∫„Åó„Åæ„Åô„ÄÇ
    public static detectConflicts(localIndex: IndexFile, remoteIndex: IndexFile): Conflict[] {
        const conflicts: Conflict[] = [];

        // „É™„É¢„Éº„Éà„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ UUID „Å®„É≠„Éº„Ç´„É´„ÅÆ parentUuid „ÇíÊØîËºÉ
        if (remoteIndex.uuid === localIndex.parentUuid) {
            // „É™„É¢„Éº„Éà„Å´Â§âÊõ¥„Åå„Å™„ÅÑ„Åü„ÇÅ„ÄÅÁ´∂Âêà„Å™„Åó
            return conflicts;
        }

        // „É™„É¢„Éº„Éà„Å´Â§âÊõ¥„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„ÅøÁ´∂Âêà„ÇíÊ§úÂá∫
        const remoteFileMap = new Map<string, FileEntry>();
        for (const file of remoteIndex.files) {
            remoteFileMap.set(file.path, file);
        }

        for (const localFile of localIndex.files) {
            const remoteFile = remoteFileMap.get(localFile.path);
            if (remoteFile) {
                if (localFile.hash !== remoteFile.hash) {
                    // „Éè„ÉÉ„Ç∑„É•ÂÄ§„ÅåÁï∞„Å™„ÇãÂ†¥Âêà„ÄÅÁ´∂Âêà„Å®Âà§Êñ≠
                    conflicts.push({
                        filePath: localFile.path,
                        localHash: localFile.hash,
                        remoteHash: remoteFile.hash,
                        localTimestamp: localFile.timestamp,
                        remoteTimestamp: remoteFile.timestamp,
                    });
                }
                // ÊØîËºÉÂæå„Å´ÂâäÈô§
                remoteFileMap.delete(localFile.path);
            }
        }

        // „É≠„Éº„Ç´„É´„Å´Â≠òÂú®„Åõ„Åö„ÄÅ„É™„É¢„Éº„Éà„Å´Â≠òÂú®„Åô„Çã„Éï„Ç°„Ç§„É´„ÇÇËÄÉÊÖÆ
        for (const remoteFile of remoteFileMap.values()) {
            conflicts.push({
                filePath: remoteFile.path,
                localHash: "",
                remoteHash: remoteFile.hash,
                localTimestamp: 0,
                remoteTimestamp: remoteFile.timestamp,
            });
        }

        return conflicts;
    }
    // „É≠„Éº„Ç´„É´„ÅÆ„ÉØ„Éº„ÇØ„Çπ„Éö„Éº„Çπ„Åã„Çâ„Éï„Ç°„Ç§„É´„É™„Çπ„Éà„ÄÅ„Éè„ÉÉ„Ç∑„É•ÂÄ§„ÄÅ„Çø„Ç§„É†„Çπ„Çø„É≥„Éó„ÇíÂèñÂæó„Åó„ÄÅ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Éï„Ç°„Ç§„É´„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ
    static async generateLocalIndexFile(previousIndex: IndexFile, options: LocalObjectManagerOptions): Promise<IndexFile> {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            throw new Error("No workspace folders found.");
        }

        const files: FileEntry[] = [];
        const previousFileMap = new Map<string, FileEntry>();
        if (previousIndex) {
            // „Éï„Ç°„Ç§„É´„Éë„Çπ„Çí„Ç≠„Éº„Å´„Åó„Å¶„Éû„ÉÉ„Éó„Å´‰øùÂ≠ò
            for (const file of previousIndex.files) {
                previousFileMap.set(file.path, file);
            }
        }

        for (const folder of workspaceFolders) {
            const filesInFolder = await vscode.workspace.findFiles(
                new vscode.RelativePattern(folder, "**/*"),
                `{**/node_modules/**,${secureNotesDir}/**}`
            );

            for (const fileUri of filesInFolder) {
                const stat = await vscode.workspace.fs.stat(fileUri);
                const relativePath = vscode.workspace.asRelativePath(fileUri, false);

                // ÂâçÂõû„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Å´Âêå„Åò„Éï„Ç°„Ç§„É´„Åå„ÅÇ„Çã„ÅãÁ¢∫Ë™ç
                const previousFileEntry = previousFileMap.get(relativePath);

                if (previousFileEntry && previousFileEntry.timestamp === stat.mtime) {
                    // „Çø„Ç§„É†„Çπ„Çø„É≥„Éó„ÅåÂêå„ÅòÂ†¥Âêà„ÄÅ„Éè„ÉÉ„Ç∑„É•ÂÄ§„ÇíÂÜçÂà©Áî®
                    files.push({
                        path: relativePath,
                        hash: previousFileEntry.hash,
                        timestamp: stat.mtime,
                    });
                } else {
                    // „Çø„Ç§„É†„Çπ„Çø„É≥„Éó„ÅåÁï∞„Å™„ÇãÂ†¥Âêà„ÄÅ„Éè„ÉÉ„Ç∑„É•ÂÄ§„ÇíÂÜçË®àÁÆó
                    const fileContent = await vscode.workspace.fs.readFile(fileUri);
                    const hash = crypto.createHash("sha256").update(fileContent).digest("hex");

                    files.push({
                        path: relativePath,
                        hash: hash,
                        timestamp: stat.mtime,
                    });
                }
            }
        }

        const indexFile: IndexFile = {
            uuid: uuidv7(),
            parentUuid: previousIndex.uuid, // „Åì„Åì„Åß„É™„É¢„Éº„Éà„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ UUID „ÇíË®≠ÂÆö
            environmentId: options.environmentId,
            files: files,
            timestamp: Date.now(),
        };


        return indexFile;
    }
    // Êñ∞„Åó„ÅÑ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Éï„Ç°„Ç§„É´„Çí„É≠„Éº„Ç´„É´„Å´‰øùÂ≠ò„Åô„ÇãÈñ¢Êï∞
    public static async saveLocalIndexFile(indexFile: IndexFile): Promise<void> {
        await vscode.workspace.fs.createDirectory(indexDirUri);
        const indexContent = Buffer.from(JSON.stringify(indexFile, null, 2), "utf-8");
        const indexFileName = `index-${indexFile.uuid}.json`;
        const indexFilePath = vscode.Uri.joinPath(indexDirUri, indexFileName);
        await vscode.workspace.fs.writeFile(indexFilePath, indexContent);
        await vscode.workspace.fs.writeFile(previousIndexIDUri, Buffer.from(indexFileName));
    }
}

### End of src/storage/LocalObjectManager.ts ###

