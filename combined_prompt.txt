以下はvscode拡張のコードです。　
- loadLatestLocalIndex関数で最終更新のindexを取得しています(これはリモートのindexを含むすべてのindexの最終更新版
です)
- loadPreviousIndexで前回ローカルで保存したindexを取得しています
- detectConflicts関数で上記２つを比較しコンフリクトを解消する処理を行っているのですが、loadLatestLocalIndexで最終が必ずしもリモートの最終版であるわけでもなくうまくコンフリクトを検出できません。
loadLatestLocalIndexi関数を修正し、index内のenvironmentIdとparentUuids情報を駆使して
直近10件のindexファイルで枝分かれしてしまっている箇所を見つけだして、それをresolveConflicts関数で競合解消するように修正できますか？
もし解決のために足らない情報があるばあいは質問してください。
### Start of package.json ###
{
  "name": "secure-notes-sync",
  "displayName": "Secure Notes Sync",
  "description": "A VSCode extension for securely syncing notes with a GitHub repository.",
  "version": "0.0.4",
  "publisher": "MasahideYAMASAKI",
  "engines": {
    "vscode": "^1.96.0"
  },
  "categories": [
    "Other"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/masahide/SecureNotesSyncVSCodeExt.git"
  },
  "main": "./dist/extension.js",
  "activationEvents": [
    "workspaceContains:.secureNotes/index"
  ],
  "contributes": {
    "configuration": {
      "type": "object",
      "title": "Secure Notes Sync",
      "properties": {
        "SecureNotesSync.awsAccessKeyId": {
          "type": "string",
          "description": "AWS Access Key ID for S3",
          "default": ""
        },
        "SecureNotesSync.s3Bucket": {
          "type": "string",
          "description": "S3 Bucket Name",
          "default": ""
        },
        "SecureNotesSync.s3Region": {
          "type": "string",
          "description": "S3 Region",
          "default": ""
        },
        "SecureNotesSync.s3Endpoint": {
          "type": "string",
          "description": "S3 Custom Endpoint (optional)",
          "default": ""
        },
        "SecureNotesSync.s3PrefixPath": {
          "type": "string",
          "description": "S3 Prefix Path (optional)",
          "default": ""
        },
        "SecureNotesSync.gitRemoteUrl": {
          "type": "string",
          "description": "GitHub repository URL for syncing the object directory. (ex: git@github.com:user/repo.git)",
          "default": "git@github.com:user/repo.git"
        },
        "SecureNotesSync.enableAutoSync": {
          "type": "boolean",
          "description": "Enable auto sync on save",
          "default": false
        },
        "SecureNotesSync.inactivityTimeoutSec": {
          "type": "number",
          "description": "Inactivity timeout in seconds for auto sync",
          "default": 60
        }
      }
    },
    "commands": [
      {
        "command": "extension.setAWSSecret",
        "title": "Set AWS secret access key"
      },
      {
        "command": "extension.setAESKey",
        "title": "Set AES encryption Key"
      },
      {
        "command": "extension.generateAESKey",
        "title": "Generate AES Key"
      },
      {
        "command": "extension.syncNotes",
        "title": "Sync Notes"
      },
      {
        "command": "extension.syncWithGitHub",
        "title": "Sync with GitHub"
      },
      {
        "command": "extension.copyAESKeyToClipboard",
        "title": "Copy AES Key to Clipboard"
      }
    ]
  },
  "scripts": {
    "vscode:prepublish": "npm run package",
    "compile": "webpack",
    "watch": "webpack --watch",
    "package": "webpack --mode production --devtool hidden-source-map",
    "compile-tests": "tsc -p . --outDir out",
    "watch-tests": "tsc -p . -w --outDir out",
    "pretest": "npm run compile-tests && npm run compile && npm run lint",
    "lint": "eslint src",
    "test": "vscode-test"
  },
  "devDependencies": {
    "@types/mocha": "^10.0.10",
    "@types/node": "22.x",
    "@types/vscode": "^1.96.0",
    "@types/which": "^3.0.4",
    "@typescript-eslint/eslint-plugin": "^8.19.0",
    "@typescript-eslint/parser": "^8.19.0",
    "@vscode/test-cli": "^0.0.10",
    "@vscode/test-electron": "^2.4.1",
    "aws-sdk": "^2.1692.0",
    "eslint": "^9.17.0",
    "ts-loader": "^9.5.1",
    "typescript": "^5.7.2",
    "webpack": "^5.97.1",
    "webpack-cli": "^6.0.1"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.722.0",
    "uuid": "^11.0.3",
    "which": "^5.0.0"
  }
}

### End of package.json ###

### Start of src/extension.ts ###
import * as vscode from "vscode";
import * as os from "os";
import { logMessage, showInfo, showError, setOutputChannel } from "./logger";
import { LocalObjectManager } from "./storage/LocalObjectManager";
import { GitHubSyncProvider } from "./storage/GithubProvider";
import * as crypto from "crypto";


const aesEncryptionKey = "aesEncryptionKey";
const appName = "SecureNotesSync";

// タイムアウトIDを保持する変数
let inactivityTimeout: NodeJS.Timeout | undefined;

// 非アクティブタイマーをリセットする関数
function resetInactivityTimer() {
  if (inactivityTimeout) {
    clearTimeout(inactivityTimeout);
  }
  const inactivityTimeoutSec = vscode.workspace.getConfiguration(appName).get<number>('inactivityTimeoutSec');
  if (inactivityTimeoutSec === undefined) {
    return;
  }
  inactivityTimeout = setTimeout(() => {
    // 非アクティブ期間が経過したら同期コマンドを実行
    vscode.commands.executeCommand("extension.syncNotes");
    vscode.commands.executeCommand("extension.syncWithGitHub");
    logMessage("非アクティブ状態が続いたため、同期コマンドを実行しました。");
  }, inactivityTimeoutSec * 1000);
}

// 設定を確認し、タイマーを開始または停止する関数
function manageInactivityTimer() {
  const isAutoSyncEnabled = vscode.workspace.getConfiguration(appName).get<boolean>("enableAutoSync", false);
  if (isAutoSyncEnabled) {
    // 設定が有効な場合、タイマーをリセット
    resetInactivityTimer();
    logMessage("自動同期が有効です。非アクティブタイマーを開始します。");
  } else {
    // 設定が無効な場合、タイマーをクリア
    if (inactivityTimeout) {
      clearTimeout(inactivityTimeout);
      inactivityTimeout = undefined;
      //logMessage("自動同期が無効です。非アクティブタイマーを停止します。");
    }
  }
}

export async function activate(context: vscode.ExtensionContext) {
  // Create output channel
  const outputChannel = vscode.window.createOutputChannel(appName);
  setOutputChannel(outputChannel);
  showInfo(`${appName} Extension Activated`);

  // 環境IDを生成or取得 (ホスト名 + UUID)
  const environmentId = await getOrCreateEnvironmentId(context);
  logMessage(`Current Environment ID: ${environmentId}`);

  // Command to Set AES Key
  let setAESKeyCommand = vscode.commands.registerCommand("extension.setAESKey", async () => {
    const secretValue = await vscode.window.showInputBox({
      prompt: "Enter AES Encryption Key (64 hex characters representing 32 bytes)",
      password: true,
      validateInput: (value) => value.length === 64 ? null : "AES Key must be 64 hex characters long"
    });
    if (secretValue) {
      await context.secrets.store(aesEncryptionKey, secretValue);
      showInfo(`${aesEncryptionKey} saved successfully.`);
    } else {
      showError(`${aesEncryptionKey} is required.`);
    }
  });

  // Command to Generate 32-Byte Encrypted Text
  let generateAESKeyCommand = vscode.commands.registerCommand("extension.generateAESKey", async () => {
    logMessage("Generating 32-byte AES encryption key...");
    const key = crypto.randomBytes(32).toString("hex"); // 32 bytes
    try {
      await context.secrets.store(aesEncryptionKey, key);
      showInfo(`Generated and stored AES key: ${key}`);
    } catch (error: any) {
      showError(`Error generating encrypted text: ${error instanceof Error ? error.message : String(error)}`);
    }
  });

  let syncCommand = vscode.commands.registerCommand("extension.syncNotes", async () => {
    try {
      const encryptKey = await context.secrets.get(aesEncryptionKey);
      if (!encryptKey) {
        showError("AES Key not set");
        return false;
      }
      const options = { environmentId: environmentId, encryptionKey: encryptKey };
      const latestIndex = await LocalObjectManager.loadLatestLocalIndex(options);
      const previousIndex = await LocalObjectManager.loadPreviousIndex(options);
      logMessage(`Loaded latest index file: ${latestIndex.uuid}\n previous index file: ${previousIndex.uuid}`);
      const localIndex = await LocalObjectManager.generateLocalIndexFile(previousIndex, options);
      const conflicts = LocalObjectManager.detectConflicts(localIndex, latestIndex);
      if (conflicts.length > 0) {
        const conflictsResolved = await LocalObjectManager.resolveConflicts(conflicts, options);
        if (!conflictsResolved) {
          showInfo("Sync aborted due to unresolved conflicts.");
          return true;
        }
      }

      const updated = await LocalObjectManager.saveEncryptedObject(localIndex.files, latestIndex, options);
      if (!updated) {
        showInfo("There are no update files.");
        return;
      }

      const newIndex = LocalObjectManager.createNewIndexFile(localIndex, [previousIndex]);
      showInfo("New local index file created.");
      LocalObjectManager.saveLocalIndexFile(newIndex, options);
    } catch (error: any) {
      showError(`Sync failed: ${error.message}`);
    }
    return true;
  });

  let syncWithGitHubCommand = vscode.commands.registerCommand("extension.syncWithGitHub", async () => {
    try {
      const gitRemoteUrl = vscode.workspace.getConfiguration(appName).get<string>('gitRemoteUrl');
      if (!gitRemoteUrl) {
        showError("設定でGitHubリポジトリURLを設定してください。");
        return;
      }
      const cloudStorageProvider = new GitHubSyncProvider(gitRemoteUrl);
      cloudStorageProvider.sync();
    } catch (error: any) {
      showError(`Cloud sync failed: ${error.message}`);
    }
  });

  // AESキーをクリップボードにコピーするコマンド
  let copyAESKeyCommand = vscode.commands.registerCommand('extension.copyAESKeyToClipboard', async () => {
    try {
      // AESキーを取得
      const aesKey = await context.secrets.get(aesEncryptionKey);
      if (!aesKey) {
        vscode.window.showErrorMessage('AES Key is not set. Please set the AES key first.');
        return;
      }

      // クリップボードにコピー
      await vscode.env.clipboard.writeText(aesKey);

      // ユーザーに通知
      vscode.window.showInformationMessage('AES Key copied to clipboard!');
    } catch (error: any) {
      vscode.window.showErrorMessage(`Failed to copy AES Key: ${error.message}`);
    }
  });

  // ユーザーアクティビティのイベントハンドラーを登録
  const userActivityEvents = [
    vscode.window.onDidChangeActiveTextEditor,
    vscode.workspace.onDidChangeTextDocument,
    vscode.workspace.onDidSaveTextDocument,
    vscode.window.onDidChangeVisibleTextEditors,
    vscode.window.onDidChangeActiveNotebookEditor,
    vscode.window.onDidChangeActiveTerminal,
    vscode.window.onDidChangeWindowState,
  ];

  // イベントを監視し、アクティビティがあったらタイマーをリセット
  const disposables = userActivityEvents.map(event => event(() => {
    if (vscode.workspace.getConfiguration(appName).get<boolean>("enableAutoSync", false)) {
      resetInactivityTimer();
    }
  }));

  // 設定変更を監視するイベントハンドラー
  const configChangeDisposable = vscode.workspace.onDidChangeConfiguration((e) => {
    if (e.affectsConfiguration(`${appName}.enableAutoSync`)) {
      manageInactivityTimer();
    }
  });

  // 初期状態でタイマーを管理
  manageInactivityTimer();

  context.subscriptions.push(
    syncCommand, setAESKeyCommand, generateAESKeyCommand, syncWithGitHubCommand,
    configChangeDisposable,
    copyAESKeyCommand,
    ...disposables
  );
  outputChannel.show(true);
}

export function deactivate() {
  if (inactivityTimeout) {
    clearTimeout(inactivityTimeout);
  }
  logMessage(`${appName} Extension Deactivated.`);
}


const ENV_ID_KEY = "encryptSyncEnvironmentId";
async function getOrCreateEnvironmentId(context: vscode.ExtensionContext): Promise<string> {
  let envId = context.globalState.get<string>(ENV_ID_KEY);
  if (!envId) {
    const hostname = os.hostname();
    envId = `${hostname}-${crypto.randomUUID()}`;
    await context.globalState.update(ENV_ID_KEY, envId);
  }
  return envId;
}

### End of src/extension.ts ###

### Start of src/logger.ts ###
import * as vscode from "vscode";

let outputChannel: vscode.OutputChannel;

export function setOutputChannel(channel: vscode.OutputChannel) {
  outputChannel = channel;
}

// Log message to output channel
export function logMessage(message: string) {
  outputChannel.appendLine(message);
}

// Show error message and log
export function showError(message: string) {
  vscode.window.showErrorMessage(message);
  logMessage(message);
}

// Show info message and log
export function showInfo(message: string) {
  vscode.window.showInformationMessage(message);
  logMessage(message);
}

### End of src/logger.ts ###

### Start of src/types.ts ###
// ファイル情報を保持するインターフェース
export interface FileEntry {
    path: string; // ファイルの相対パス
    hash: string; // ファイルのSHA-256ハッシュ値（暗号化前のデータに対して計算）
    timestamp: number; // ファイルの最終更新タイムスタンプ
    deleted?: boolean; // ファイルが削除されたかどうか
}

// インデックスファイルの構造
export interface IndexFile {
    uuid: string; // インデックスファイルのUUID（Version 7）
    environmentId: string; // 追加
    parentUuids: string[]; // 親インデックスファイルのUUID
    files: FileEntry[]; // ファイル情報のリスト
    timestamp: number; // インデックスファイルの作成タイムスタンプ
}

// 競合情報を保持するインターフェース
export interface Conflict {
    filePath: string; // 競合しているファイルのパス
    localHash: string; // ローカルファイルのハッシュ値
    remoteHash: string; // リモートファイルのハッシュ値
    localTimestamp: number; // ローカルファイルのタイムスタンプ
    remoteTimestamp: number; // リモートファイルのタイムスタンプ
}
export type LocalObjectManagerOptions = {
    environmentId: string;
    encryptionKey: string;
};
### End of src/types.ts ###

### Start of src/storage/GithubProvider.ts ###
// storage/providers/GitHubSyncProvider.ts
import * as vscode from "vscode";
import { IStorageProvider } from './IStorageProvider';
import { objectDirUri } from './LocalObjectManager';
import { showError, logMessage } from '../logger';
import * as cp from 'child_process';
import which from 'which';
import * as fs from 'fs';

export class GitHubSyncProvider implements IStorageProvider {
    private gitRemoteUrl: string;
    private gitPath: string;

    constructor(gitRemoteUrl: string) {
        this.gitRemoteUrl = gitRemoteUrl;
        this.gitPath = findGitExecutable();
    }

    public async sync(): Promise<void> {
        logMessage(`gitPath: ${this.gitPath}`);
        try {
            const objectDir = objectDirUri.fsPath;
            // ディレクトリがGitリポジトリかどうかを確認
            const isGitRepo = await this.isGitRepository(objectDir);
            if (!isGitRepo) {
                // Gitリポジトリを初期化
                const gitattributesUri = vscode.Uri.joinPath(objectDirUri, '.gitattributes');
                await vscode.workspace.fs.writeFile(gitattributesUri, new TextEncoder().encode('* binary'));
                await this.execCmd(this.gitPath, ['init'], objectDir);
                await this.execCmd(this.gitPath, ['remote', 'add', 'origin', this.gitRemoteUrl], objectDir);
                await this.execCmd(this.gitPath, ['fetch', 'origin'], objectDir);
                // Check if 'main' branch exists on remote
                const checkMainBranch = await this.execCmd(this.gitPath, ['ls-remote', '--heads', 'origin', 'main'], objectDir);
                await this.execCmd(this.gitPath, ['add', '.'], objectDir);
                await this.execCmd(this.gitPath, ['commit', '-m', 'add'], objectDir);
                if (checkMainBranch.stdout.trim() === '') {
                    await this.execCmd(this.gitPath, ['branch', '-M', 'main'], objectDir);
                } else {
                    // 強制的にオブジェクトディレクトリとマージ
                    await this.execCmd(this.gitPath, ['branch', '-M', 'backup'], objectDir);
                    await this.execCmd(this.gitPath, ['fetch', 'origin', 'main'], objectDir);
                    await this.execCmd(this.gitPath, ['checkout', 'main'], objectDir);
                    // 強制マージ
                    await this.execCmd(this.gitPath, ['merge', 'backup', '--allow-unrelated-histories', '-X', 'ours', '-m', 'merge'], objectDir);
                    await this.execCmd(this.gitPath, ['branch', '-D', 'backup'], objectDir);
                    logMessage("オブジェクトディレクトリをGitHubと強制マージしました");
                }
                await this.execCmd(this.gitPath, ['push', '-u', 'origin', 'main'], objectDir);
                logMessage("オブジェクトディレクトリをGitHubと同期しました。");
                return;
            }
            await this.execCmd(this.gitPath, ['pull', 'origin', 'main'], objectDir);
            // すべての変更をコミット
            await this.execCmd(this.gitPath, ['add', '.'], objectDir);
            try {
                await this.execCmd(this.gitPath, ['diff', '--cached', '--quiet'], objectDir);
                logMessage("変更がありません。");
                return;
            } catch { }
            await this.execCmd(this.gitPath, ['commit', '-m', 'sync'], objectDir);
            await this.execCmd(this.gitPath, ['push', 'origin', 'main'], objectDir);
            logMessage("オブジェクトディレクトリをGitHubと同期しました。");
        } catch (error) {
            showError(`sync GitHub error:${(error as Error).message}`);
        }
    }

    // Gitコマンドを実行するヘルパー関数
    private async execCmd(cmd: string, args: string[], cwd: string): Promise<{ stdout: string, stderr: string }> {
        return new Promise((resolve, reject) => {
            cp.execFile(cmd, args, { cwd: cwd }, (error, stdout, stderr) => {
                if (error) {
                    reject(new Error(`execFile error: ${cwd}> ${cmd} ${args.join(' ')}\nstdout:'${stdout}', stderr:'${stderr}'`));
                } else {
                    logMessage(`execFile: ${cwd}> ${cmd} ${args.join(' ')}`);
                    if (stdout !== '') { logMessage(`${stdout}`); }
                    if (stderr !== '') { logMessage(`Err:${stderr}`); }
                    resolve({ stdout, stderr });
                }
            });
        });
    }

    // Check if a directory is a git repository
    private async isGitRepository(dir: string): Promise<boolean> {
        try {
            await this.execCmd(this.gitPath, ['rev-parse', '--is-inside-work-tree'], dir);
            return true;
        } catch (error) {
            return false;
        }
    }
}

function findGitExecutable(): string {
    let gitPath: string;

    // First, search for Git in PATH
    try {
        gitPath = which.sync('git');
        return gitPath;
    } catch (e) {
        // Git not found in PATH
    }

    // Define predefined paths based on platform
    const platform = process.platform;
    let predefinedPaths: string[];

    switch (platform) {
        case 'win32': // Windows
            predefinedPaths = [
                'C:\\Program Files\\Git\\bin\\git.exe',
                'C:\\Git\\bin\\git.exe',
                'C:\\Windows\\System32\\git.exe'
            ];
            break;
        case 'darwin': // macOS
            predefinedPaths = [
                '/usr/local/bin/git',
                '/usr/bin/git'
            ];
            break;
        case 'linux': // Linux
            predefinedPaths = [
                '/usr/local/bin/git',
                '/usr/bin/git',
                '/bin/git'
            ];
            break;
        default:
            throw new Error(`Unsupported platform: ${platform}`);
    }

    // Search predefined paths
    for (const p of predefinedPaths) {
        if (fs.existsSync(p)) {
            gitPath = p;
            return gitPath;
        }
    }

    // If Git is not found, throw an error
    throw new Error('Git executable not found.');
}
### End of src/storage/GithubProvider.ts ###

### Start of src/storage/IStorageProvider.ts ###
// src/IStorageProvider.ts
export interface IStorageProvider {
    /**
     * rsync 的な双方向のファイル同期を行う
     *  - ローカルの .enc ファイルをクラウドへ
     *  - クラウドにしかない .enc ファイルをローカルへ
     */
    sync(): Promise<void>;
}

### End of src/storage/IStorageProvider.ts ###

### Start of src/storage/LocalObjectManager.ts ###
// src/LocalObjectManager.ts
import * as vscode from "vscode";
import * as crypto from "crypto";
import { logMessage } from "../logger";
import { IndexFile, FileEntry, Conflict, LocalObjectManagerOptions } from "../types";
import { v7 as uuidv7 } from 'uuid';

const secureNotesDir = ".secureNotes";
const objectDirName = "objects";
const indexDirName = "indexes";
const filesDirName = "files";
const previousIndexIDFilename = "index";
const rootUri = getRootUri();
export const secureNootesUri = vscode.Uri.joinPath(rootUri, secureNotesDir);
export const objectDirUri = vscode.Uri.joinPath(secureNootesUri, objectDirName);
const previousIndexIDUri = vscode.Uri.joinPath(secureNootesUri, previousIndexIDFilename);
const indexDirUri = vscode.Uri.joinPath(objectDirUri, indexDirName);
const filesDirUri = vscode.Uri.joinPath(objectDirUri, filesDirName);

interface FileIndex {
    originalFile: string;
    encryptedFile: string;
}

// ワークスペースフォルダを取得
function getRootUri(): vscode.Uri {
    const workspaceUri = vscode.workspace.workspaceFolders ? vscode.workspace.workspaceFolders[0].uri : undefined;
    if (!workspaceUri) {
        throw new Error("No workspace folder found.");
    }
    return workspaceUri;
}

export class LocalObjectManager {
    /**
     * ワークスペース内ファイルを暗号化し、.secureNotes に保存
     */
    public static async saveEncryptedObject(
        localFiles: FileEntry[],
        latestIndex: IndexFile,
        options: LocalObjectManagerOptions
    ): Promise<boolean> {
        // リモートのファイルハッシュ値のセットを作成
        const latestFileHashes = new Set(latestIndex.files.map((file) => file.hash));
        let updated = false;
        for (const file of localFiles) {
            // ファイルがリモートインデックスに存在するか確認
            if (latestFileHashes.has(file.hash)) {
                continue; // 既に存在する場合、アップロードをスキップ
            }
            // ファイルを読み込み
            const fileUri = vscode.Uri.joinPath(rootUri, file.path);
            const fileContent = await vscode.workspace.fs.readFile(fileUri);

            // ファイルを暗号化
            const encryptedContent = this.encryptContent(Buffer.from(fileContent), options.encryptionKey);

            // objects directory に保存
            const { dirName, fileName } = this.getHashPathParts(file.hash);
            const encryptedFileName = vscode.Uri.joinPath(filesDirUri, dirName, fileName);
            await vscode.workspace.fs.writeFile(encryptedFileName, encryptedContent);
            logMessage(`save file:${file.path}, to:${encryptedFileName.path}`);
            updated = true;
        }
        return updated;
    }

    private static getUUIDPathParts(uuid: string): { dirName: string; fileName: string } {
        const dirName = uuid.substring(0, 6);
        const fileName = uuid.substring(6);
        return { dirName, fileName };
    }
    private static getHashPathParts(uuid: string): { dirName: string; fileName: string } {
        const dirName = uuid.substring(0, 2);
        const fileName = uuid.substring(2);
        return { dirName, fileName };
    }

    /**
     * uri にあるすべての fileのパス一覧
     */
    private static async listFiles(uri: vscode.Uri): Promise<string[]> {
        // .secureNotes/indexes ディレクトリが存在しない場合は空配列を返す
        try {
            await vscode.workspace.fs.stat(uri);
        } catch (error) {
            return [];
        }
        const dirs = await vscode.workspace.fs.readDirectory(uri);
        return dirs.filter((f) => f[1] === vscode.FileType.File).map((f) => f[0]);
    }
    /**
     * uri にあるすべてのdirのパス一覧
     */
    private static async listDirs(uri: vscode.Uri): Promise<string[]> {
        // .secureNotes/indexes ディレクトリが存在しない場合は空配列を返す
        try {
            await vscode.workspace.fs.stat(uri);
        } catch (error) {
            return [];
        }
        const dirs = await vscode.workspace.fs.readDirectory(uri);
        return dirs.filter((f) => f[1] === vscode.FileType.Directory).map((f) => f[0]);
    }


    public static latestString(strings: string[]): string {
        if (strings.length === 0) { return ""; }
        return strings.reduce((a, b) => (a > b ? a : b));
    }
    /**
     * ローカルにあるうち、もっとも新しいインデックスファイルを読み込む
     */
    public static async loadLatestLocalIndex(options: LocalObjectManagerOptions): Promise<IndexFile> {
        const latestDir = this.latestString(await this.listDirs(indexDirUri));
        const dir = vscode.Uri.joinPath(indexDirUri, latestDir);
        const latestFilePath = this.latestString(await this.listFiles(dir));
        const latestIndexFileUri = vscode.Uri.joinPath(indexDirUri, latestDir, latestFilePath);
        if (latestFilePath.length === 0) {
            // インデックスファイルが存在しない場合は新規作成
            logMessage(`Latest index file not found. Creating new index`);
            return {
                uuid: "",
                parentUuids: [],
                environmentId: options.environmentId,
                files: [],
                timestamp: 0,
            };
        }

        const encryptContent = await vscode.workspace.fs.readFile(latestIndexFileUri);
        const content = this.decryptContent(Buffer.from(encryptContent), options.encryptionKey);
        return JSON.parse(content.toString()) as IndexFile;
    }

    // 前回のインデックスファイルを読み込む関数
    public static async loadPreviousIndex(options: LocalObjectManagerOptions): Promise<IndexFile> {
        try {
            const indexContent = await vscode.workspace.fs.readFile(previousIndexIDUri);
            const uuidparts = this.getUUIDPathParts(indexContent.toString());
            const encryptedIndex = await vscode.workspace.fs.readFile(vscode.Uri.joinPath(indexDirUri, uuidparts.dirName, uuidparts.fileName));
            const index = this.decryptContent(Buffer.from(encryptedIndex), options.encryptionKey);
            return JSON.parse(index.toString());
        } catch (error) {
            logMessage(`Previous index file not found. Creating new index`);
            return {
                uuid: "",
                parentUuids: [],
                environmentId: options.environmentId,
                files: [],
                timestamp: 0,
            };
        }
    }

    /**
     * 新しい <UUID> を作成し保存
     */
    public static createNewIndexFile(localIndex: IndexFile, parentIndexes: IndexFile[]): IndexFile {
        const newUUID = uuidv7();
        const newIndexFile: IndexFile = {
            uuid: newUUID,
            parentUuids: parentIndexes.map((index) => index.uuid),
            environmentId: localIndex.environmentId,
            files: localIndex.files,
            timestamp: Date.now(),
        };

        return newIndexFile;
    }

    /**
     * AES-256-CBC で暗号化
     */
    private static encryptContent(content: Buffer, key: string): Buffer {
        const iv = crypto.randomBytes(16);
        const keyBuffer = Buffer.from(key, "hex");
        const cipher = crypto.createCipheriv("aes-256-cbc", keyBuffer, iv);
        const encrypted = Buffer.concat([cipher.update(content), cipher.final()]);
        return Buffer.concat([iv, encrypted]);
    }

    /**
     * AES-256-CBC で復号
     */
    private static decryptContent(encryptedContent: Buffer, key: string): Buffer {
        const iv = encryptedContent.subarray(0, 16);
        const encryptedText = encryptedContent.subarray(16);
        const keyBuffer = Buffer.from(key, "hex");
        const decipher = crypto.createDecipheriv("aes-256-cbc", keyBuffer, iv);
        return Buffer.concat([decipher.update(encryptedText), decipher.final()]);
    }

    // 復号化した内容を返す共通関数
    private static async decryptFileFromLocalObject(fileHash: string, options: LocalObjectManagerOptions): Promise<Uint8Array> {
        const { dirName, fileName } = this.getHashPathParts(fileHash);
        const filePath = vscode.Uri.joinPath(filesDirUri, dirName, fileName);
        const content = await vscode.workspace.fs.readFile(filePath);
        try {
            return this.decryptContent(Buffer.from(content), options.encryptionKey);
        } catch (error: any) {
            logMessage(`Failed to fetch or decrypt file: ${fileHash}.Error: ${error.message} `);
            throw error;
        }
    }
    // オブジェクトディレクトリからファイルを取得し、ワークスペースに保存する共通関数
    private static async fetchDecryptAndSaveFile(
        filePath: string,
        fileHash: string,
        options: LocalObjectManagerOptions,
        conflictFileName?: string,
    ): Promise<void> {
        try {
            const decryptedContent = await this.decryptFileFromLocalObject(fileHash, options);
            const savePath = conflictFileName ? conflictFileName : filePath;

            // ローカルファイルパスを取得
            const localUri = vscode.Uri.joinPath(vscode.Uri.file(rootUri.fsPath), savePath);

            // ローカルファイルに保存
            await vscode.workspace.fs.writeFile(localUri, decryptedContent);
            logMessage(`Saved remote file to local path: ${savePath} `);
        } catch (error: any) {
            logMessage(`Failed to save remote file to local path: ${filePath}.Error: ${error.message} `);
            throw error;
        }
    }
    // リモートのファイルでローカルを上書き
    private static async overwriteLocalFileWithRemote(
        filePath: string,
        fileHash: string,
        options: LocalObjectManagerOptions,
    ): Promise<void> {
        await this.fetchDecryptAndSaveFile(filePath, fileHash, options);
        logMessage(`Overwrote local file with remote content: ${filePath} `);
    }
    // リモートのファイルを別名で保存
    public static async saveRemoteFileAsConflict(
        filePath: string,
        fileHash: string,
        options: LocalObjectManagerOptions
    ): Promise<void> {
        // コンフリクト用のファイル名を生成（例: conflict-YYYYMMDD-HHmmss-ファイル名.ext）
        const timestamp = new Date().toISOString().replace(/[:.]/g, "-").replace("T", "_").split("Z")[0];
        const conflictFileName = `conflict - ${timestamp} -${filePath} `;
        await this.fetchDecryptAndSaveFile(filePath, fileHash, options, conflictFileName);
        logMessage(`Saved remote file as conflict file: ${conflictFileName} `);
    }

    // 検出された競合をユーザーに通知し、解決します。
    public static async resolveConflicts(
        conflicts: Conflict[],
        options: LocalObjectManagerOptions
    ): Promise<boolean> {
        for (const conflict of conflicts) {
            if (conflict.localHash.length === 0) {
                logMessage(`Remote only file: ${conflict.filePath} `);
                await this.fetchDecryptAndSaveFile(conflict.filePath, conflict.remoteHash, options);
                continue;
            }
            const choice = await vscode.window.showQuickPick(
                ["Keep Local Version", "Keep Remote Version", "Save Remote as Conflict File", "Abort Sync"],
                {
                    placeHolder: `Conflict detected in file: ${conflict.filePath} `,
                }
            );

            if (choice === "Keep Local Version") {
                // ローカルの変更を適用（何もしない）
                continue;
            } else if (choice === "Keep Remote Version") {
                // リモートのファイルでローカルを上書き
                await this.overwriteLocalFileWithRemote(conflict.filePath, conflict.remoteHash, options);
            } else if (choice === "Save Remote as Conflict File") {
                // リモートのファイルを別名で保存
                await this.saveRemoteFileAsConflict(conflict.filePath, conflict.remoteHash, options);
            } else if (choice === "Abort Sync" || !choice) {
                // 同期を中止
                return false;
            }
        }
        return true;
    }
    // ローカルとリモートのインデックスファイルを比較し、競合を検出します。
    public static detectConflicts(localIndex: IndexFile, remoteIndex: IndexFile): Conflict[] {
        const conflicts: Conflict[] = [];

        // リモートのインデックス UUID とローカルの parentUuid を比較
        if (localIndex.parentUuids.includes(remoteIndex.uuid)) {
            // リモートに変更がないため、競合なし
            return [];
        }

        // リモートに変更がある場合のみ競合を検出
        const remoteFileMap = new Map<string, FileEntry>();
        for (const file of remoteIndex.files) {
            remoteFileMap.set(file.path, file);
        }

        for (const localFile of localIndex.files) {
            const remoteFile = remoteFileMap.get(localFile.path);
            if (remoteFile) {
                if (localFile.hash !== remoteFile.hash) {
                    // ハッシュ値が異なる場合、競合と判断
                    conflicts.push({
                        filePath: localFile.path,
                        localHash: localFile.hash,
                        remoteHash: remoteFile.hash,
                        localTimestamp: localFile.timestamp,
                        remoteTimestamp: remoteFile.timestamp,
                    });
                }
                // 比較後に削除
                remoteFileMap.delete(localFile.path);
            }
        }

        // ローカルに存在せず、リモートに存在するファイルも考慮
        for (const remoteFile of remoteFileMap.values()) {
            conflicts.push({
                filePath: remoteFile.path,
                localHash: "",
                remoteHash: remoteFile.hash,
                localTimestamp: 0,
                remoteTimestamp: remoteFile.timestamp,
            });
        }

        return conflicts;
    }
    // ローカルのワークスペースからファイルリスト、ハッシュ値、タイムスタンプを取得し、インデックスファイルを生成します。
    static async generateLocalIndexFile(previousIndex: IndexFile, options: LocalObjectManagerOptions): Promise<IndexFile> {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            throw new Error("No workspace folders found.");
        }

        const files: FileEntry[] = [];
        const previousFileMap = new Map<string, FileEntry>();
        if (previousIndex) {
            // ファイルパスをキーにしてマップに保存
            for (const file of previousIndex.files) {
                previousFileMap.set(file.path, file);
            }
        }

        for (const folder of workspaceFolders) {
            const filesInFolder = await vscode.workspace.findFiles(
                new vscode.RelativePattern(folder, "**/*"),
                `{**/node_modules/**,${secureNotesDir}/**}`
            );

            for (const fileUri of filesInFolder) {
                const stat = await vscode.workspace.fs.stat(fileUri);
                const relativePath = vscode.workspace.asRelativePath(fileUri, false);

                // 前回のインデックスに同じファイルがあるか確認
                const previousFileEntry = previousFileMap.get(relativePath);

                if (previousFileEntry && previousFileEntry.timestamp === stat.mtime) {
                    // タイムスタンプが同じ場合、ハッシュ値を再利用
                    files.push({
                        path: relativePath,
                        hash: previousFileEntry.hash,
                        timestamp: stat.mtime,
                    });
                } else {
                    // タイムスタンプが異なる場合、ハッシュ値を再計算
                    const fileContent = await vscode.workspace.fs.readFile(fileUri);
                    const hash = crypto.createHash("sha256").update(fileContent).digest("hex");

                    files.push({
                        path: relativePath,
                        hash: hash,
                        timestamp: stat.mtime,
                    });
                }
            }
        }

        const parentUuids = (previousIndex.uuid !== "") ? [previousIndex.uuid] : [];
        const indexFile: IndexFile = {
            uuid: uuidv7(),
            parentUuids: parentUuids, // ここでリモートのインデックス UUID を設定
            environmentId: options.environmentId,
            files: files,
            timestamp: Date.now(),
        };


        return indexFile;
    }
    // 新しいインデックスファイルをローカルに保存する関数
    public static async saveLocalIndexFile(indexFile: IndexFile, options: LocalObjectManagerOptions): Promise<void> {
        const { dirName, fileName } = this.getUUIDPathParts(indexFile.uuid);
        const dirPath = vscode.Uri.joinPath(indexDirUri, dirName);
        await vscode.workspace.fs.createDirectory(dirPath);
        const indexContent = Buffer.from(JSON.stringify(indexFile, null, 2), "utf-8");
        const indexFileName = indexFile.uuid;
        const indexFilePath = vscode.Uri.joinPath(indexDirUri, dirName, fileName);
        const encryptedIndex = this.encryptContent(indexContent, options.encryptionKey);
        await vscode.workspace.fs.writeFile(indexFilePath, encryptedIndex);
        await vscode.workspace.fs.writeFile(previousIndexIDUri, Buffer.from(indexFileName));
    }
}

### End of src/storage/LocalObjectManager.ts ###

